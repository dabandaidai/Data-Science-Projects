{
  "doc-c988b0b6700798f50e9d8278e63bfba0": {
    "content": "Nothing here for you loser."
  },
  "doc-925728e6bebbdcc3152ead66ecd6367b": {
    "content": "The story's top theme is a guy licking a lady's pussy."
  },
  "doc-2a7604cea512063306bc231ef84801d6": {
    "content": "---\nlayout: spec\nlatex: true\nmermaid: true\n---\n\nEECS 280 Project 4: Machine Learning\n====================================\n{: .primer-spec-toc-ignore }\n\nWinter 2025 release.\n\nProject due 8:00pm EST Friday March 28, 2024.\n\nYou may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)).\n\n## Introduction\n\nAutomatically identify the subject of posts from the EECS 280 Piazza using natural language processing and machine learning techniques.\n\nThe learning goals of this project include using container ADTs, such as sets and maps. You will also gain experience designing and implementing a substantial application program.\n\nFor example, your program will be able to read a Piazza post like this and figure out that it's about Project 3: Euchre.\n\n<img src=\"images/image28.png\" width=\"640px\" />\n\n\n## Setup\nSet up your visual debugger and version control, then submit to the autograder.\n\n### Visual debugger\nDuring setup, name your project `ml-classifier`. Use this starter files link: `https://eecs280staff.github.io/ml-classifier/starter-files.tar.gz`\n\n| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |\n\nYou should end up with a folder with starter files that look like this. You may also have a `main.cpp` file after following the setup tutorial, which you should rename to `classifier.cpp`. If not, you will create a `classifier.cpp` file in the [Classifier](#classifier) section.\n```console\n$ ls\nMakefile\t\t\t\t\t\ttrain_small.csv\ncsvstream.hpp\t\t\t\t\ttrain_small_train_only.out.correct\ninstructor_student.out.correct\tw14-f15_instructor_student.csv\nprojects_exam.out.correct\t\tw16_instructor_student.csv\nsp16_projects_exam.csv\t\t\tw16_projects_exam.csv\ntest_small.csv\t\t\t\t\tw16_projects_exam_train_only.out.correct\ntest_small.out.correct\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each starter file.\n\n| File(s) | Description |\n| ------- | ----------- |\n| `csvstream.hpp` | Library for reading CSV files. |\n| `train_small.csv`<br> `test_small.csv`<br> `test_small.out.correct`<br> `train_small_train_only.out.correct` | Sample input and output for the classifier. |\n| `sp16_projects_exam.csv`<br> `w14-f15_instructor_student.csv`<br> `w16_instructor_student.csv`<br> `w16_projects_exam.csv`<br>`w16_projects_exam_train_only.out.correct`<br> `instructor_student.out.correct`<br> `projects_exam.out.correct` | Piazza data input from past terms, with correct output. |\n| `Makefile` | Helper commands for building. |\n\n### Version control\nSet up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).\n\nAfter you're done, you should have a local repository with a \"clean\" status and your local repository should be connected to a remote GitHub repository.\n```console\n$ git status\nOn branch main\nYour branch is up-to-date with 'origin/main'.\n\nnothing to commit, working tree clean\n$ git remote -v\norigin\thttps://github.com/awdeorio/ml-classifier.git (fetch)\norigin\thttps://githubcom/awdeorio/ml-classifier.git (push)\n```\n\nYou should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).\n```console\n$ head .gitignore\n# This is a sample .gitignore file that's useful for C++ projects.\n...\n```\n\n### Group registration\nRegister your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.\n\n\n## ML and NLP Background\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Skim this section the first time through.  Refer back to it while you're coding the [Classifier](#classifier).\n</div>\n\n### Machine Learning and Classification\n\nThe goal for this project is to write an intelligent program that can\n**classify** Piazza posts according to topic. This task is easy for humans -\nwe simply read and understand the content of the post, and the topic is\nintuitively clear. But how do we compose an algorithm to do the same? We\ncan't just tell the computer to \"look at it\" and understand. This is\ntypical of problems in artificial intelligence and natural language\nprocessing.\n\n![](images/image28.png)\n\nWe know this is about Euchre, but how can we write an algorithm that\n\"knows\" that?\n\nWith a bit of introspection, we might realize each individual word is a\nbit of evidence for the topic about which the post was written. Seeing a\nword like \"card\" or \"spades\" leads us toward the Euchre\nproject. We judge a potential label for a post based on how likely it is\ngiven all the evidence. Along these lines, information about how common\neach word is for each topic essentially constitutes our classification\nalgorithm.\n\nBut we don't have that information (i.e. that algorithm). You could try\nto sit down and write out a list of common words for each project, but\nthere's no way you'll get them all. For example, the word \"lecture\"\nappears much more frequently in posts about exam preparation. This makes\nsense, but we probably wouldn't come up with it on our own. And what if\nthe projects change? We don't want to have to put in all that work\nagain.\n\nInstead, let's write a program to comb through Piazza posts from\nprevious terms (which are already tagged according to topic) and learn\nwhich words go with which topics. Essentially, the result of our program\nis an algorithm! This approach is called (supervised) machine learning.\nOnce we've trained the classifier on some set of Piazza posts, we can\napply it to new ones written in the future.\n\n![](images/image29.png){: .invert-colors-in-dark-mode }\n\nAt a high level, the classifier we'll implement works by assuming a\nprobabilistic model of how Piazza posts are composed, and then finding\nwhich label (e.g. our categories of  \"euchre\", \"exam\", etc.) is the most\nprobable source of a particular post.\n\nAll the details of natural language processing (NLP) and machine\nlearning (ML) techniques you need to implement the project are described\nhere. You are welcome to consult other resources, but there are many\nkinds of classifiers that have subtle differences. The classifier we\ndescribe here is a simplified version of a \"Multi-Variate Bernoulli\nNaive Bayes Classifier\". If you find other resources, but you're not\nsure they apply, make sure to check them against this specification.\n\n[This document](naive_bayes.html) provides a more complete description\nof the way the classifier works, in case you're interested in the math\nbehind the formulas here.\n\n### Piazza Dataset\n\nFor this project, we retrieved archived Piazza posts from EECS 280 in\npast terms. We will focus on two different ways to divide Piazza posts\ninto labels (i.e. categories).\n\n- By **topic**. Labels: \"exam\", \"calculator\", \"euchre\", \"image\", \"recursion\",\n  \"statistics\"\n\n  Example: Posts extracted from `w16_projects_exam.csv`\n\n  | label | content |\n  | ----- | ------- |\n  | exam | will final grades be posted within 72 hours |\n  | calculator | can we use the friend class list in stack |\n  | euchre | weird problem when i try to compile euchrecpp |\n  | image | is it normal for the horses tests to take 10 minutes |\n  | recursion | is an empty tree a sorted binary tree |\n  | statistics | are we supposed to have a function for summary |\n  | ... | ... |\n\n- By **author**. Labels: \"instructor\", \"student\"\n\n  Example: Posts extracted from `w14-f15_instructor_student.csv`\n\n  | label | content |\n  | ----- | ------- |\n  | instructor | disclaimer not actually a party just extra OH |\n  | student | how can you use valgrind with calccpp |\n  | student | could someone explain to me what the this keyword means |\n  | ... | ... |\n\nThe Piazza datasets are Comma Separated Value (CSV) files. The label for\neach post is found in the \"tag\" column, and the content in the\n\"content\" column. There may be other columns in the CSV file; your\ncode should ignore all but the \"tag\" and \"content\" columns. **You may\nassume all Piazza files are formatted\ncorrectly, and that post content and labels only contain lowercase\ncharacters, numbers, and no punctuation.** You must use the\n`csvstream.hpp` library (see\n[https://github.com/awdeorio/csvstream](https://github.com/awdeorio/csvstream) for\ndocumentation) to read CSV files in your application. The\n`csvstream.hpp` file itself is included with the starter code.\n\n**Your classifier should not hardcode any labels. Instead, it should use\nthe exact set of labels that appear in the training data.**\n\n<div id=\"splitting-a-whitespace-delimited-string\" class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Here's how to split a string into words. You may use this code as given.\n```c++\n// EFFECTS: Return a set of unique whitespace delimited words\nset<string> unique_words(const string &str) {\n  istringstream source(str);\n  set<string> words;\n  string word;\n  while (source >> word) {\n    words.insert(word);\n  }\n  return words;\n}\n```\n</div>\n\nWe have included several Piazza datasets with the project:\n  - `train_small.csv` - Made up training data intended for small-scale\n    testing.\n  - `test_small.csv` - Made up test data intended for small-scale\n    testing.\n  - `w16_projects_exam.csv` - (Train) Real posts from W16 labeled by\n    topic.\n  - `sp16_projects_exam.csv` - (Test) Real posts from Sp16 labeled by\n    topic.\n  - `w14-f15_instructor_student.csv` - (Train) Real posts from four\n    terms labeled by author.\n  - `w16_instructor_student.csv` - (Test) Real posts from W16 Piazza\n    labeled by author.\n\nFor the real datasets, we have indicated which are intended for training\nvs. testing.\n\n### Bag of Words Model\n\nWe will treat a Piazza post as a \"**bag of words**\" - each post is simply characterized by which words it includes. The ordering of words is ignored, as are multiple occurrences of the same word. These two posts would be considered equivalent:\n- \"the left bower took the trick\"\n- \"took took trick the left bower bower\"\n\nThus, we could imagine the post-generation process as a person sitting down and going through every possible word and deciding which to toss into a bag.\n\n#### Conditional Probability\n\nWe write $$ P(A) $$ to denote the probability (a number\nbetween 0 and 1) that some event $$ A $$ will occur.\n$$ P(A \\mid B) $$ denotes the probability that event\n$$ A $$ will occur given that we already know event\n$$ B $$ has occurred. For example,\n$$ P(bower \\mid euchre) \\approx 0.007 $$. This means that if a Piazza post is about the\neuchre project, there is a 0.7% chance it will contain the word bower\n(we should say \"at least once\", technically, because of the bag of words\nmodel).\n\n### Training\n\nBefore the classifier can make predictions, it needs to be trained on a\nset of previously labeled Piazza posts (e.g. `train_small.csv` or\n`w16_projects_exam.csv`). Your application should process each post in\nthe training set, and record the following information:\n\n  - The total number of posts in the entire training set.\n  - The number of unique words in the entire training set. (The\n    **vocabulary size**.)\n  - For each word $$ w $$, the number of posts in the\n    entire training set that contain $$ w $$.\n  - For each label $$ C $$, the number of posts with that\n    label.\n  - For each label $$ C $$ and word\n    $$ w $$, the number of posts with label\n    $$ C $$ that contain $$ w $$.\n\n### Prediction\n\nHow do we predict a label for a new post?\n\nGiven a new Piazza post $$ X $$, we must determine the\nmost probable label $$ C $$, based on what the classifier\nhas learned from the training set. A measure of the likelihood of $$ C $$ is\nthe **log-probability score** given the post:\n\n$$\n\\ln P(C) + \\ln P(w_1 \\mid C) + \\ln P(w_2 \\mid C) + \\cdots + \\ln P(w_n \\mid C)\n$$\n\n**Important**: Because we're using the bag-of-words model, the words $$ w_1, w_2, \\ldots, w_n $$ in this formula are only the [unique\nwords](#splitting-a-whitespace-delimited-string) in the\npost, not including duplicates\\! To ensure consistent results, make\nsure to add the contributions from each word in alphabetic order.\n\nThe classifier should predict whichever label has the highest\nlog-probability score for the post. If multiple labels are tied, predict\nwhichever comes first alphabetically.\n\n$$ \\ln P(C) $$ is the **log-prior** probability of label\n$$ C $$ and is a reflection of how common it is:\n\n$$\n\\ln P(C) = \\ln \\left( \\frac{\\text{number of training posts with label } C}{\\text{number of training posts}} \\right)\n$$\n\n$$ \\ln P(w \\mid C) $$ is the **log-likelihood** of a word\n$$ w $$ given a label $$ C $$, which is a\nmeasure of how likely it is to see word $$ w $$ in posts\nwith label $$ C $$. The regular formula for\n$$ \\ln P(w \\mid C) $$ is:\n\n$$\n\\ln P(w \\mid C) = \\ln \\left( \\frac{\\text{number of training posts with label } C \\text{ that contain } w}{\\text{number of training posts with label } C} \\right)\n$$\n\nHowever, if $$ w $$ was never seen in a post with label\n$$ C $$ in the training data, we get a log-likelihood of\n$$ -\\infty $$, which is no good. Instead, use one of these two alternate formulas:\n\n---\n\n$$\n\\ln P(w \\mid C) = \\ln \\left( \\frac{\\text{number of training posts that contain } w}{\\text{number of training posts}} \\right)\n$$\n\n(Use when $$ w $$ does not occur in posts labeled $$ C $$ but does occur in the training data overall.)\n\n---\n\n$$\n\\ln P(w \\mid C) = \\ln \\left( \\frac{1}{\\text{number of training posts}} \\right)\n$$\n\n(Use when $$ w $$ does not occur anywhere at all in the\ntraining set.)\n\n---\n\n\n## Classifier\n\nWrite the classifier in `classifier.cpp` using the [bag of words model](#bag-of-words-model).\n\nRun the classifier on a small dataset.\n```console\n$ ./classifier.exe train_small.csv test_small.csv\n```\n\n### Setup\n\nIf you created a `main.cpp` while following the setup tutorial, rename it to `classifier.cpp` if you have not already done so.  Otherwise, create a new file `classifier.cpp` ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#add-new-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#add-new-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#add-new-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#add-new-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#touch)).\n\nAdd \"hello world\" code if you haven't already.\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n  cout << \"Hello World!\\n\";\n}\n```\n\nThe classifier program should compile and run.\n```console\n$ make classifier.exe\n$ ./classifier.exe\nHello World!\n```\n\nConfigure your IDE to debug the classifier program.\n\n<table>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/classifier.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/classifier.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `classifier.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `classifier.cpp`\n  - Exclude any other tests\n  </td>\n</tr>\n</table>\n\nConfigure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)). We recommend starting with the smallest input in train-only mode, `train_small.csv`.\n\nTo compile and run the smallest input at the command line:\n```console\n$ make classifier.exe\n$ ./classifier.exe train_small.csv\n```\n\n### Command Line Interface\n\nHere is the usage message for the top-level application:\n```console\n$ ./classifier.exe\nUsage: classifier.exe TRAIN_FILE [TEST_FILE]\n```\n\nThe classifier application always requires a file for training, and it optionally takes a file for testing. The training file must have at least one post, but the test file may have no posts. You may assume all files are in the correct format, with a header that has at least the \"tag\" and \"content\" columns.\n\nUse the provided small-scale files for initial testing and to check your output formatting:\n\n```console\n$ ./classifier.exe train_small.csv\n$ ./classifier.exe train_small.csv test_small.csv\n```\n\nCorrect output is in `train_small_train_only.out.correct` and\n`test_small.out.correct`. The output format is discussed in detail below.\n\n#### Error Checking\n\nThe program checks that the command line arguments obey the following\nrule:\n\n- There are 2 or 3 arguments, including the executable name itself\n  (i.e. `argv[0]`).\n\nIf this is violated, print out the usage message and then quit\nby returning a non-zero value from `main`. **Do not use the `exit`\nlibrary function, as this fails to clean up local objects.**\n\n```c++\ncout << \"Usage: classifier.exe TRAIN_FILE [TEST_FILE]\" << endl;\n```\n{: data-variant=\"no-line-numbers\" }\n\nIf any file cannot be opened, print out the following message, where\n`filename` is the name of the file that could not be opened, and quit by\nreturning a non-zero value from `main`.\n\n```c++\ncout << \"Error opening file: \" << filename << endl;\n```\n{: data-variant=\"no-line-numbers\" }\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** The `csvstream` constructor will throw a `csvstream_exception` containing the correct error message if a file cannot be opened. The example at [https://github.com/awdeorio/csvstream#error-handling](https://github.com/awdeorio/csvstream#error-handling) shows how to handle the exception with a `try`/`catch` block.\n</div>\n\nYou do not need to do any error checking for command-line arguments or\nfile I/O other than what is described on this page. However, you must\nuse precisely the error messages given here in order to receive credit.\n(**Just literally use the code given here to print them.**)\n\nAs mentioned earlier, you may assume all Piazza data files are in the\ncorrect format.\n\n### Design\n\nHere is some high-level guidance:\n\n1.  First, your application should read posts from a file (e.g.\n    `train_small.csv`) and use them to train the classifier. After\n    training, your classifier abstraction should store the information\n    mentioned in the [Training](#training) section.\n2.  Your classifier should be able to compute the log-probability\n    score of a post (i.e. a collection of words) given a particular\n    label. To predict a label for a new post, it should choose the label\n    that gives the highest log-probability score.  See the [Prediction](#prediction) section.\n3.  Read posts from a file (e.g. `test_small.csv`) to use as testing\n    data. For each post, predict a label using your classifier.\n\nSome of these steps have output associated with them. See the \"output\"\nsection below for the details.\n\nThe structure\nof your classifier application, including which procedural abstractions\nand/or ADTs to use for the classifier, is entirely up to you. Make sure\nyour decisions are informed by carefully considering the classifier and\ntop-level application described in this specification.\n\nWe **strongly** suggest you make a class to represent the classifier - the\nprivate data members for the class should keep track of the classifier\nparameters learned from the training data, and the public member\nfunctions should provide an interface that allows you to train the\nclassifier and make predictions for new piazza posts.\n\nYou should write RMEs and appropriate comments to describe the\ninterfaces for the abstractions you choose (ADTs, classes, functions,\netc.). You should also write unit tests to verify each component works\non its own.\n\nYou are welcome to use any part of the C++ standard library in your top-level classifier\napplication. See our [C++ Standard Library Containers](containers.html) reference for a description of several containers and examples of how to use them. In particular, `std::map` and `std::set` will be\nuseful for this project.\n\n### Example\n\nWe've provided full example output for a small input (`train_small.csv` and `test_small.csv`).  The output is in `test_small.out.correct`.  The output in train-only mode is in `train_small_train_only.out.correct`, here we've indicated train-only output with \"(TRAIN-ONLY)\".  Some lines are indented by two spaces.\n\nTo run this example at the command line in train-only mode:\n```console\n$ make classifier.exe\n$ ./classifier.exe train_small.csv\n```\n\nTo run with test data and generate predictions:\n```console\n$ ./classifier.exe train_small.csv test_small.csv\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Debug output differences with `diff -y -B`, which shows differences side-by-side and ignores whitespace.  We'll use the `less` pager so we can scroll through the long terminal output.  Press `q` to quit.\n```console\n$ make classifier.exe\n$ ./classifier.exe train_small.csv > train_small_train_only.out\n$ diff -y -B train_small_train_only.out train_small_train_only.out.correct | less  # q to quit\n```\n</div>\n\nAdd this line at the beginning of your `main` function to set floating\npoint precision:\n\n```c++\ncout.precision(3);\n```\n{: data-variant=\"no-line-numbers\" }\n\nFirst, print information about the training data:\n\n- (TRAIN-ONLY) Line-by-line, the label and content for each training document.\n  ```\n  training data:\n    label = euchre, content = can the upcard ever be the left bower\n    label = euchre, content = when would the dealer ever prefer a card to the upcard\n    label = euchre, content = bob played the same card twice is he cheating\n    ...\n    label = calculator, content = does stack need its own big three\n    label = calculator, content = valgrind memory error not sure what it means\n  ```\n  {: data-variant=\"no-line-numbers\" }\n- The number of training posts.\n  ```\n  trained on 8 examples\n  ```\n  {: data-variant=\"no-line-numbers\" }\n- (TRAIN-ONLY) The vocabulary size (the number of unique words in all training content).\n  ```\n  vocabulary size = 49\n  ```\n  {: data-variant=\"no-line-numbers\" }\n- An extra blank line\n\nIn train-only mode, also print information about the classifier\ntrained on the training posts. Whenever classes or words are listed,\nthey are in alphabetic order.\n\n- (TRAIN-ONLY) The classes in the training data, and the number of examples for each.\n  ```\n  classes:\n    calculator, 3 examples, log-prior = -0.981\n    euchre, 5 examples, log-prior = -0.47\n  ```\n  {: data-variant=\"no-line-numbers\" }\n- (TRAIN-ONLY) For each label, and for each word that occurs for that label: The\n  number of posts with that label that contained the word, and the\n  log-likelihood of the word given the label.\n  ```\n  classifier parameters:\n    calculator:assert, count = 1, log-likelihood = -1.1\n    calculator:big, count = 1, log-likelihood = -1.1\n    ...\n    euchre:twice, count = 1, log-likelihood = -1.61\n    euchre:upcard, count = 2, log-likelihood = -0.916\n    ...\n   ```\n   {: data-variant=\"no-line-numbers\" }\n- (TRAIN-ONLY) An extra blank line\n\nFinally, if a test file is provided, use the classifier to predict\nclasses for each example in the testing data. Print information about\nthe test data as well as these predictions.\n\n- Line-by-line, the \"correct\" label, the predicted label and its log-probability\n  score, and the content for each test. Insert a blank line after each for\n  readability.\n  ```\n  test data:\n    correct = euchre, predicted = euchre, log-probability score = -13.7\n    content = my code segfaults when bob is the dealer\n\n    correct = euchre, predicted = calculator, log-probability score = -12.5\n    content = no rational explanation for this bug\n\n    correct = calculator, predicted = calculator, log-probability score = -13.6\n    content = countif function in stack class not working\n  ```\n  {: data-variant=\"no-line-numbers\" }\n- The number of correct predictions and total number of test posts.\n  ```\n  performance: 2 / 3 posts predicted correctly\n  ```\n  {: data-variant=\"no-line-numbers\" }\n\nThe last thing printed should be a newline character.\n\n### Accuracy\n\nIn case you're curious, here's the accuracy for the large datasets. Not too bad!\n\n|                               Command                                |  Accuracy   |\n| -------------------------------------------------------------------- | ----------- |\n| `./classifier.exe w16_projects_exam.csv sp16_projects_exam.csv`              | 245 / 332   |\n| `./classifier.exe w14-f15_instructor_student.csv w16_instructor_student.csv` | 2602 / 2988 |\n\n### Efficiency\n\nWhile efficiency is not a primary goal for this project, you should\naim for your code to run the largest test case above in no more than a\nminute. Some common causes of slowdown you should avoid:\n\n- Processing a post more than once (including reading it more than\n  once or saving all the data in a vector).\n- Iterating over a map to find something rather than using `[]` or `find()`.\n- Passing strings, pairs, or containers by value.\n- Iterating by value in a range-based for loop.\n\nRefer to the [Project 2 perf\ntutorial](https://eecs280staff.github.io/p2-cv/perf.html)\nfor instructions on how to use the `perf` tool to identify slow\nfunctions.\n\n## Submission and Grading\n\nSubmit these files to the [autograder](https://autograder.io).\n  - `classifier.cpp`\n\nThis project will be autograded for correctness and programming style. See the [style checking\ntutorial](https://eecs280staff.github.io/p1-stats/setup_style.html)\nfor the criteria and how to check your style automatically on CAEN.\n\n### Testing\n\nRun all the tests.  For this project, the tests only consist of system tests.\n\n```console\n$ make test\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Run commands in parallel with `make -j`.\n```console\n$ make -j4 test\n```\n{: data-variant=\"no-line-numbers\" }\n</div>\n\n### Requirements and Restrictions\n\n| DO | DO NOT |\n| -- | ------ |\n| Put all top-level application code in `classifier.cpp`. | Create additional files other than `classifier.cpp`. |\n| Create any ADTs or functions you wish for your top-level classifier application. | Write everything in the `main()` function. |\n| Use any part of the C++ standard library for your top level classifier application, including `map` and `set`. | Write your own implementation of maps and sets -- they will likely be too slow. |\n| Follow course style guidelines. | Use non-const static or global variables. |\n| [Check for undefined behavior](https://eecs280staff.github.io/p1-stats/setup_asan.html#p1-stats) using address sanitizer and other tools | \"It runs fine on my machine!\" |\n\n\n## Acknowledgments\n\nAndrew DeOrio and James Juett wrote the original project and specification. Amir Kamil contributed to code structure, style, and implementation details. This project was developed for EECS 280, Fall 2016 at the University of Michigan. The classifer was forked into a separate project in Fall 2024."
  },
  "doc-29956e61e81cc3347872a3a643ff7d35": {
    "content": "---\nlayout: spec\nmermaid: true\n---\n\nEECS 280 Project 3: Euchre\n==========================\n{: .primer-spec-toc-ignore }\n\nWinter 2025 release.\n\nCheckpoint due 8:00pm EST Monday February 24, 2025.  See [Submission and Grading / Checkpoint](#checkpoint).\n\nFull project due 8:00pm EST Wednesday March 12, 2025.\n\nYou may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)). If you work alone, you must work alone on both the checkpoint and the full project. If you work with a partner, you must work with the same partner on the checkpoint and the full project. You may not work alone on the checkpoint and then add a partner for the full project.\n\n<!--\n## Change Log\n\n-->\n\n## Introduction\nEuchre (pronounced \"YOO-kur\") is a card game popular in Michigan.\n\nThe learning goals of this project include Abstract Data Types in C++, Derived Classes, Inheritance, and Polymorphism.  You'll gain practice with C++-style Object Oriented Programming (OOP) with classes and virtual functions.\n\nWhen you're done, you'll have a program that simulates a game of Euchre, supporting a AI player and a Human player.\n```console\n$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Simple Kunle Simple Liskov Simple\nHand 0\nIvan deals\nJack of Diamonds turned up\nJudea passes\nKunle passes\nLiskov passes\nHuman player Ivan's hand: [0] Nine of Diamonds\nHuman player Ivan's hand: [1] Ten of Diamonds\nHuman player Ivan's hand: [2] Jack of Hearts\nHuman player Ivan's hand: [3] Queen of Hearts\nHuman player Ivan's hand: [4] Ace of Clubs\nHuman player Ivan, please enter a suit, or \"pass\":\nDiamonds\nIvan orders up Diamonds\n...\n```\n{: data-variant=\"legacy\" }\n\n\n## Setup\nSet up your visual debugger and version control, then submit to the autograder.\n\n### Visual debugger\nDuring setup, name your project `p3-euchre`. Use this starter files link: `https://eecs280staff.github.io/euchre/starter-files.tar.gz`\n\n| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |\n\nIf you created a `main.cpp` while following the setup tutorial, rename it to `euchre.cpp`. Otherwise, create a new file `euchre.cpp`.  You should end up with a folder with starter files that looks like this.  You may have already renamed files like `Card.cpp.starter` to `Card.cpp`.\n```console\n$ ls\nCard.cpp.starter        Pack_public_tests.cpp     euchre_test00.out.correct\nCard.hpp                Pack_tests.cpp.starter    euchre_test01.out.correct\nCard_public_tests.cpp   Player.hpp                euchre_test50.in\nCard_tests.cpp.starter  Player_public_tests.cpp   euchre_test50.out.correct\nMakefile                Player_tests.cpp.starter  pack.in\nPack.hpp                euchre.cpp                unit_test_framework.hpp\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each starter file.\n\n| File(s) | Description |\n| ------- | ----------- |\n| `Card.hpp` | Abstraction representing a playing card. |\n| `Card.cpp.starter` | Starter code for the `Card`. |\n| `Card_tests.cpp` | Your `Card` unit tests. |\n| `Card_public_tests.cpp` | Compile check test for `Card.cpp`. |\n| `Pack.hpp` | Abstraction representing a pack cards. |\n| `Pack_tests.cpp` | Add your `Pack` unit tests to this file. |\n| `Pack_public_tests.cpp` | Compile check test for `Pack.cpp`. |\n| `Player.hpp` | Abstraction representing a euchre player. |\n| `Player_tests.cpp` | Your `Player` unit tests. |\n| `Player_public_tests.cpp` | Compile check test for `Player.cpp`. |\n| `pack.in` | Input file containing a Euchre deck. |\n| `Makefile` | Helper commands for building. |\n| `euchre_test00.out.correct` <br>`euchre_test01.out.correct` | Correct output for system tests with Simple player.  |\n| `euchre_test50.in` <br>`euchre_test50.out.correct` | Input and correct output for system tests with Human player. |\n| `unit_test_framework.hpp` | A simple unit-testing framework. |\n\n### Version control\nSet up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).\n\nAfter you're done, you should have a local repository with a \"clean\" status and your local repository should be connected to a remote GitHub repository.\n```console\n$ git status\nOn branch main\nYour branch is up-to-date with 'origin/main'.\n\nnothing to commit, working tree clean\n$ git remote -v\norigin\thttps://github.com/awdeorio/p3-euchre.git (fetch)\norigin\thttps://githubcom/awdeorio/p3-euchre.git (push)\n```\n\nYou should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).\n```console\n$ head .gitignore\n# This is a sample .gitignore file that's useful for C++ projects.\n...\n```\n\n### Group registration\nRegister your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.\n\n## EECS 280 Euchre Rules\n\nThere are many variants of Euchre. Our particular version is based on\na variety commonly played in Michigan with a few changes to make it\nfeasible as a coding project.\n\nOur step-by-step explanation of a game of \"EECS 280 Euchre\" can be found in a [YouTube video](https://www.youtube.com/watch?v=M0jGJ0NRcrc) and a [PDF](https://drive.google.com/file/d/14MSt1WdtnRbfgpPiMp9YuKn2wQ4Z83Ir/view?usp=sharing).\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Skim this section the first time through.  Refer back to it while you're coding.\n</div>\n\n### Players\n{:.primer-spec-toc-ignore}\n\nThere are four players numbered 0-3. If the players sat around the\ntable, it would look like this:\n\n![](images/image2.png){: .invert-colors-in-dark-mode }\n\nThere are two teams: players 0 and 2 are *partners*, as are 1 and 3.\nEach player has left and right *neighbors*. For example, 1 is to the\nleft of 0, and 3 is to the right of 0. That means 1 is 0's left\n*neighbor*, and 3 is 0's right *neighbor*.\n\n### The Cards\n{:.primer-spec-toc-ignore}\n\nEuchre uses a deck of 24 *playing cards*, each of which has two\nproperties: a *rank* and a *suit*. The ranks are 9, 10, *Jack*,\n*Queen*, *King*, and *Ace*, and the suits are *Spades*, *Hearts*,\n*Clubs*, and *Diamonds*. Each card is unique &mdash; there are no duplicates.\nThroughout this document, we sometimes refer to ranks or suits using\nonly the first letter of their name. Farther below, we describe how to\ndetermine the [ordering of the cards](#value-of-cards).\n\n### Playing the Game\n\nAt a high level, a game of Euchre involves several rounds, which are\ncalled *hands*. Each hand consists of the following phases.\n\nEach hand:\n\n1.  [Setup table](#setup-table)\n    1.  [Shuffle](#shuffle)\n    2.  [Deal](#deal)\n2.  [Making Trump](#making-trump)\n    1.  [Round One](#round-one)\n    2.  [Round Two](#round-two)\n3.  [Trick Taking](#trick-taking)\n4.  [Scoring](#scoring)\n\nWe describe each in more detail below.\n\n### Setup table\n\n#### Shuffle\n{:.primer-spec-toc-ignore}\n\nThe dealer shuffles the deck at the beginning of each hand. The\nalgorithm you will implement for shuffling is a variant of a riffle\nshuffle called an \"in shuffle\"\n([https://en.wikipedia.org/wiki/In\\_shuffle](https://en.wikipedia.org/wiki/In_shuffle)).\nCut the deck exactly in half and then interleave the two halves,\nstarting with the second half. Thus, the card originally at position\n12 goes to position 0, the one originally at position 0 goes to\nposition 1, the one originally at position 13 goes to position 2, and\nso on. Do this in-shuffle process 7 times.\n\nYou will also implement an option to run the game with shuffling\ndisabled - when this option is chosen, just reset the pack any time\nshuffling would be called for. This may make for easier testing and\ndebugging.\n\n#### Deal\n{:.primer-spec-toc-ignore}\n\nIn each hand, one player is designated as the *dealer* (if humans were\nplaying the game, the one who passes out the cards). In our game,\nplayer 0 deals during the first hand. Each subsequent hand, the role\nof dealer moves one player to the left.\n\nEach player receives five cards, dealt in alternating batches of 3 and 2.\nThat is, deal 3-2-3-2 cards then 2-3-2-3 cards, for a total of 5\ncards each. The player to the left of the dealer receives the first\nbatch, and dealing continues to the left until 8 batches have been\ndealt.\n\nFour cards remain in the deck after the deal. The next card in the\npack is called the upcard (it is turned face up, while the other cards\nare all face down). It plays a special role in the next phase. The\nthree remaining cards are not used for the current hand.\n\n### Making Trump\n\nDuring this phase, the trump suit is determined by whichever player\nchooses to *order up*.\n\n#### Round One\n{:.primer-spec-toc-ignore}\n\nThe suit of the *upcard* is used to propose a *trump* suit whose cards\nbecome more valuable during the upcoming hand. Players are given the\nopportunity to *order up* (i.e. select the suit of the upcard to be\nthe trump suit) or *pass*, starting with the player to the dealer's\nleft (also known as the *eldest hand*) and progressing once around the\ncircle to the left. If any player orders up, the upcard's suit becomes\ntrump and the dealer is given the option to replace one of their cards\nwith the upcard.\n\n#### Round Two\n{:.primer-spec-toc-ignore}\n\nIf all players *pass* during the first round, there is a second round\nof *making*, again beginning with the eldest hand. The upcard's suit\nis rejected and cannot be ordered up. Instead, the players may *order\nup* any suit other than the upcard's suit. The dealer does not have\nthe opportunity to pick up the upcard during round two.\n\nIf *making* reaches the dealer during the second round, a variant\ncalled *screw the dealer* is invoked: the dealer must order up a suit\nother than the rejected suit.\n\n(Note for pro Euchre players: for simplicity, we have omitted \"going\nalone\" in this version.)\n\n### Trick Taking\n\nOnce the trump has been determined, five *tricks* are played. For each\ntrick, players take turns laying down cards, and whoever played the\nhighest card *takes* the trick.\n\nDuring each trick, the player who plays first is called the *leader*.\nFor the first trick, the eldest hand leads.\n\nAt the beginning of each trick, the leader *leads* a card, which\naffects which cards other players are allowed to play, as well as the\nvalue of each card played (see below). Each other player must *follow\nsuit* (play a card with the same suit as the led card) if they are\nable, and otherwise may play any card (it is removed from their hand).\nPlay moves to the left around the table, with each player playing one\ncard.\n\nA trick is won by the player who played the highest valued card (see\nbelow to determine comparative values). The winner of the trick\n*leads* the next one.\n\n### Scoring\n\nThe team that takes the majority of tricks receives points for that hand.\n* If the team that ordered up the trump suit takes 3 or 4 tricks, they get 1 point.\n* If the team that ordered up the trump suit takes all 5 tricks, they get 2 points. This is called a *march*.\n* If the team that did not order up takes 3, 4, or 5 tricks, they receive 2 points. This is called *euchred*.\n\nTraditionally, the first side to reach 10 points wins the game. In\nthis project, the number of points needed to win is specified when the\nprogram is run.\n\n### Value of cards\n\nIn order to determine which of two cards is better, you must pay\nattention to the context in which they are being compared. There are\nthree separate contexts, which depend on whether or not a trump or led\nsuit is present.\n\nIn the simplest case, cards are ordered by rank (A \\> K \\> Q \\> J \\>\n10 \\> 9), with ties broken by suit (D \\> C \\> H \\> S).\n\nIf a *trump suit* is present, all trump cards are more valuable than\nnon-trump cards. That means a 9 of the trump suit will beat an Ace of\na non-trump suit. Additionally, two special cards called *bowers* take\non different values than normal.\n\n  - *Right Bower*: The Jack of the trump suit. This is the most\n    valuable card in the game.\n  - *Left Bower*: The Jack of the \"same color\" suit as trump is\n    **considered to be a trump** (regardless of the suit printed on\n    the card) and is the second most valuable card.\n\nThe suit of the left bower is called *next*, while the two suits of the opposite color are called *cross* suits.\n\nIf a *led suit* is present as well as a trump suit, the ordering is\nthe same except that all cards of the led suit are considered more\nvaluable than all non-trump-suit, non-led-suit cards. Note that it is\npossible for the trump suit and led suit to be the same.\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Pitfall:** The left bower is always considered the trump suit.  For example, if Diamonds is trump, the Jack of Hearts is also considered a Diamond, not a Heart.\n</div>\n\n![](images/image1.png)\n\nThe above shows card orderings in the possible contexts. Cards in\nhigher rows are greater than those in lower rows. Within rows, cards\nfarther to the left are greater. Note the right bower (blue outline)\nand left bower (red outline).\n\n### Euchre Glossary\n\n**Trump:** A suit whose cards are elevated above their normal rank\nduring play.\n\n**Right Bower:** The Jack card of the *Trump* suit, which is\nconsidered the highest-valued card in Euchre.\n\n**Left Bower:** The Jack from the other suit of the same color as the\n*Trump* suit, considered the second highest-valued card in Euchre. The\n*Left Bower* is also considered a *Trump* card.\n\n**Face or Ace:** The Jack, Queen, and King cards are generally pictured with people on them and are called \"face\" cards. These and the ace cards are more powerful than the 9 or 10 and factor into the simple player's strategy.\n\n**Next Suit:** The suit of the same color as trump.\n\n**Cross Suits:** The two suits of the opposite color as trump.\n\n**Making:** The process in which a trump card is chosen, consists of\ntwo rounds.\n\n**Eldest:** Player to the left of the dealer.\n\n**Upcard:** The up-facing card in front of the dealer that proposes\nthe trump suit.\n\n**Order Up:** Accepts the *Upcard* suit.\n\n**Pass:** Player rejects the suit and passes on the decision to the\nnext player.\n\n**Screw the Dealer:** When making* reaches the dealer on round two,\n*the dealer must *order up* a suit other than the rejected one.\n\n**Lead:** The first card played by the eldest* hand, regardless of who\n*is the maker.\n\n**Leader:** Person playing the lead* card in a trick, allowed to lead*\n*any card.\n\n**March:** When the side that made trump* wins all 5 tricks.\n\n**Euchred:** When the side that didn't make trump* wins 3, 4, or 5\n*tricks.\n\n\n## Card\n\nWrite an abstract data type (ADT) for a playing card.  Refer back to the [Value of cards section](#value-of-cards) while you're working on the card ADT.\n\nBefore getting started, take a look at the [Operator Overloading Tutorial](operator_overloading.html).  That will help you understand functions like:\n```c++\nbool operator<(const Card &lhs, const Card &rhs);\n```\n\nNext, see the short [Enumerated Type Tutorial](enum.html).  It explains code like this from `Card.hpp`.\n```c++\nenum Suit {\n  SPADES   = 0,\n  HEARTS   = 1,\n  CLUBS    = 2,\n  DIAMONDS = 3,\n};\n```\n\nWrite implementations in `Card.cpp` for the functions declared in\n`Card.hpp`.\n\nRun the public Card tests.\n```console\n$ make Card_public_tests.exe\n$ ./Card_public_tests.exe\n```\n\nWrite tests for `Card` in `Card_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make Card_tests.exe\n$ ./Card_tests.exe\n```\n\nSubmit `Card.cpp` and `Card_tests.cpp` to the [autograder](https://autograder.io).\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Compare the underlying numeric representation of an `enum`.\n```c++\nRank r = JACK;\nr == JACK; // true\n\nSuit s1 = SPADES;\nSuit s2 = DIAMONDS;\ns1 < s2;  // true\n```\n</div>\n\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Card.cpp.starter` -> `Card.cpp`\n-  `Card_tests.cpp.starter` -> `Card_tests.cpp`\n\nEdit `Card.cpp`, adding a function stub for each of the Card member functions in `Card.hpp`.\n```c++\nCard::Card() {\n  assert(false);\n}\n```\n{: data-title=\"Card.cpp\" }\n\nEdit `Card.cpp`, adding  function stubs for each of the non-member non-operator functions in `Card.hpp`.  Here are a few examples.\n```c++\nSuit Suit_next(Suit suit) {\n  assert(false);\n}\n\nbool Card_less(const Card &a, const Card &b, Suit trump) {\n  assert(false);\n}\n```\n{: data-title=\"Card.cpp\" }\n\nEdit `Card.cpp`, adding  function stubs for each of the overloaded operators in `Card.hpp`.  Here are a few examples.\n```c++\nstd::ostream & operator<<(std::ostream &os, const Card &card) {\n  assert(false);\n}\n\nbool operator<(const Card &lhs, const Card &rhs) {\n  assert(false);\n}\n\n```\n{: data-title=\"Card.cpp\" }\n\nThe Card tests should compile and run.  Expect them to fail at this point because the `Card.cpp` starter code contains function stubs.\n```console\n$ make Card_public_tests.exe\n$ ./Card_public_tests.exe\n$ make Card_tests.exe\n$ ./Card_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Card_public_tests.cpp`, `Card.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Card_tests.cpp`, `Card.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Card_public_tests.cpp`\n  - Exclude `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Card_tests.cpp`\n  - Exclude `Card_public_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Testing\nThis section contains a few tips for writing your own tests in `Card_tests.cpp`.\n\nHere's how to create a Card and check its rank and suit.\n```c++\nCard ace_hearts(ACE, HEARTS);\nASSERT_EQUAL(ace_hearts.get_rank(), ACE);\nASSERT_EQUAL(ace_hearts.get_suit(), HEARTS);\n```\n\nIn this example, the overloaded less-than operator runs: `bool operator<(const Card &lhs, const Card &rhs);`.  Notice that the suits are ordered to break ties (see the [Value of Cards](#value-of-cards) section).\n```c++\nCard ace_hearts(ACE, HEARTS);\nCard ace_diamonds(ACE, DIAMONDS);\nASSERT_TRUE(ace_hearts < ace_diamonds);\n```\n\n## Pack\n\nWrite an abstract data type (ADT) for a pack of playing cards.\n\nWrite implementations in `Pack.cpp` for the functions declared in\n`Pack.hpp`.\n\nRun the public Pack tests.\n```console\n$ make Pack_public_tests.exe\n$ ./Pack_public_tests.exe\n```\n\nWrite tests for `Pack` in `Pack_tests.cpp` using the unit test framework. While you should write your own tests for `Pack` to ensure that your implementation is correct, you do not have to submit your tests to the autograder.\n```console\n$ make Pack_tests.exe\n$ ./Pack_tests.exe\n```\n\nSubmit `Pack.cpp` to the [autograder](https://autograder.io).  Don't forget to include the code you finished earlier, `Card.cpp` and `Card_tests.cpp`.\n\n### Default constructor\n{: .primer-spec-toc-ignore }\n\nThe default `Pack` constructor initializes a full pack with cards in order from lowest to highest.\n```c++\nPack();\n```\n\nYou can take advantage of an `enum`'s underlying integer representation to loop over all its values.\n```c++\nfor (int s = SPADES; s <= DIAMONDS; ++s) {\n  Suit suit = static_cast<Suit>(s);\n}\n```\n\n### Stream input constructor\n{: .primer-spec-toc-ignore }\n\nA second `Pack` constructor reads a pack from stream input. [Later](#command-line-arguments), your `main` function will open an input file and then call this constructor on the input stream.\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Pack_tests.cpp.starter` -> `Pack_tests.cpp`\n\nCreate a new file `Pack.cpp`.  Add a function stub for every function prototype in `Pack.hpp`.  Remember to `#include \"Pack.hpp\"`.\n\nFor example:\n```c++\n#include \"Pack.hpp\"\nvoid Pack::reset() {\n  assert(false);\n  assert(next); // DELETEME: avoid error \"private field is not used\"\n}\n```\n{: data-title=\"Pack.cpp\" }\n\nThe Pack tests should compile and run.  Expect them to fail at this point because the `Pack.cpp` contains function stubs.\n```console\n$ make Pack_public_tests.exe\n$ ./Pack_public_tests.exe\n$ make Pack_tests.exe\n$ ./Pack_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Pack_public_tests.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Pack_tests.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Pack_public_tests.cpp`\n  - Exclude `Pack_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Pack_tests.cpp`\n  - Exclude `Pack_public_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Reading the Pack\n\nOne of the `Pack` constructors reads a pack from stream input. [Later](#interface), your `main` function will open an input file and then call this constructor on the input stream.\n```c++\nPack(std::istream& pack_input);\n```\n{: data-title=\"Pack.hpp\" }\n\nThe `pack.in` file provided with the project contains an example of the input format, with cards listed in \"new pack\" order:\n\n```\nNine of Spades\nTen of Spades\nJack of Spades\n...\nQueen of Diamonds\nKing of Diamonds\nAce of Diamonds\n```\n{: data-title=\"pack.in\" data-variant=\"no-line-numbers\" }\n\nYour implementation may assume any pack input is formatted correctly, with exactly 24\nunique and correctly formatted cards.\n\n## Player\n\nWe'll implement two players: a simple AI player and a human-controlled player that reads instructions from standard input (`cin`).  We have provided an abstract base class in `Player.hpp`.\n\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Player_tests.cpp.starter` -> `Player_tests.cpp`\n\nCreate a new file `Player.cpp`.  Add function stubs for the two \"vanilla\" functions in `Player.hpp`. Remember to `#include \"Player.hpp\"`. Later, you'll add new classes and member functions using derived classes, which you can ignore for now.\n```c++\n#include \"Player.hpp\"\nPlayer * Player_factory(const std::string &name, const std::string &strategy) {\n  assert(false);\n}\n\nstd::ostream & operator<<(std::ostream &os, const Player &p) {\n  assert(false);\n}\n```\n{: data-title=\"Player.cpp\" }\n\nThe Player tests should compile and run.  Expect them to fail at this point because the `Player.cpp` contains function stubs.\n```console\n$ make Player_public_tests.exe\n$ ./Player_public_tests.exe\n$ make Player_tests.exe\n$ ./Player_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Player_public_tests.cpp`, `Player.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Player_tests.cpp`, `Player.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Player_public_tests.cpp`\n  - Exclude `Player_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Player_tests.cpp`\n  - Exclude `Player_public_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Player factory\n\nSince the specific types of Players are hidden inside `Player.cpp`, we\nneed to write a *factory function* that returns a pointer to a\n`Player` with the correct dynamic type. We also need the pointed-to\nobjects to stick around after the factory function finishes, so we'll\ncreate the players using *dynamically allocated memory*. The prototype\nfor `Player_factory` can be found in `Player.hpp`, and the\nimplementation will go in `Player.cpp`.\n\n```c++\nPlayer * Player_factory(const std::string &name, \n                        const std::string &strategy) {\n  // We need to check the value of strategy and return \n  // the corresponding player type.\n  if (strategy == \"Simple\") {\n    // The \"new\" keyword dynamically allocates an object.\n    return new SimplePlayer(name);\n  }\n  // Repeat for each other type of Player\n  ...\n  // Invalid strategy if we get here\n  assert(false);\n  return nullptr;\n}\n```\n{: data-title=\"Player.cpp\" }\n\n### Simple Player\n\nImplement the Simple Player in `Player.cpp` by creating a class that derives from our `Player` abstract base class.  Override each Player function in `Player.cpp` for the functions declared in `Player.hpp`. \n\nMuch of the strategy for our Simple Player can be implemented using\nthe comparison functions provided by the Card interface.\n\nThe Simple Player should not print any output.\n\nRun the public Simple Player tests.\n```console\n$ make Player_public_tests.exe\n$ ./Player_public_tests.exe\n```\n\nWrite tests for the Simple Player in `Player_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make Player_tests.exe\n$ ./Player_tests.exe\n```\n\nSubmit `Player.cpp` and `Player_tests.cpp` to the [autograder](https://autograder.io).  Don't forget to include the code you finished earlier, `Card.cpp`, `Card_tests.cpp`, and `Pack.cpp`.\n\n#### Making\n{:.primer-spec-toc-ignore}\n\nIn making trump, a Simple Player considers the upcard, which player\ndealt, and whether it is the first or second round of making trump. A\nmore comprehensive strategy would consider the other players'\nresponses, but we will keep it simple.\n\nDuring round one, a Simple Player considers ordering up the suit\nof the upcard, which would make that suit trump. They will order up if\nthat would mean they have two or more cards that are either face or ace\ncards of the trump suit (the right and left bowers, and Q, K, A of\nthe trump suit, which is the suit proposed by the upcard). (A Simple\nPlayer does not consider whether they are the dealer and could gain an\nadditional trump by picking up the upcard.)\n\nDuring round two, a Simple Player considers ordering up the suit with\nthe same color as the upcard, which would make that suit trump. They\nwill order up if that would mean they have one or more cards that are either\nface or ace cards of the trump suit in their hand (the right and left bowers, and Q, K, A of the order-up\nsuit). For example, if the upcard is a Heart and the player has the\nKing of Diamonds in their hand, they will order up Diamonds. The\nSimple Player will not order up any other suit. If making reaches the\ndealer during the second round, we invoke *screw the dealer*, where\nthe dealer is forced to order up. In the case of screw the dealer, the\ndealer will always order up the suit with the same color as the\nupcard.\n\n#### Adding the Upcard and Discarding a Card\n{:.primer-spec-toc-ignore}\n\nIf the trump suit is ordered up during round one, the dealer picks up\nthe upcard. The dealer then discards the lowest card in their hand,\neven if this is the upcard, for a final total of five cards. (Note that\nat this point, the trump suit is the suit of the upcard.)\n\n#### Leading Tricks\n{:.primer-spec-toc-ignore}\n\nWhen a Simple Player leads a trick, they play the highest non-trump\ncard in their hand. If they have only trump cards, they play the\nhighest trump card in their hand.\n\n#### Playing Tricks\n{:.primer-spec-toc-ignore}\n\nWhen playing a card, Simple Players use a simple strategy that\nconsiders only the suit that was led. A more complex strategy would\nalso consider the cards on the table.\n\nIf a Simple Player can follow suit, they play the highest card that\nfollows suit. Otherwise, they play the lowest card in their hand.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Here's a nice way to remove a Card from a vector using [`vector::erase`](https://cplusplus.com/reference/vector/vector/erase/).\n```c++\nvector<Card> hand;  // Assume hand is full of cards\nhand.erase(hand.begin() + i);  // Remove card i\n```\n</div>\n\n### Human Player\n\nThe Human Player reads input from the human user. You may assume all\nuser input is correctly formatted and has correct values. You may also\nassume the user will follow the rules of the game and not try to\ncheat. See [Example With Human Players](#example-with-human-players) for\nexact output for a game with a human player.\n\nImplement the Human Player in `Player.cpp` by creating a class that derives from our `Player` abstract base class.  Override each Player function in `Player.cpp` for the functions declared in `Player.hpp`. \n\nThe tests in `Player_tests.cpp` and `Player_public_tests.cpp` test only the Simple Player.  You'll have to wait until you have a working Euchre game driver to test the Human player.\n\nSubmit `Player.cpp` again to the [autograder](https://autograder.io).  Don't forget to include the code you finished earlier, `Card.cpp`, `Card_tests.cpp`, `Pack.cpp`, and `Player_tests.cpp`.\n\n#### Making Trump\n{:.primer-spec-toc-ignore}\n\nWhen making trump reaches a Human Player, first print the Player's\nhand. Then, prompt the user for their decision to pass or order up. The user will\nthen enter one of the following: \"Spades\", \"Hearts\", \"Clubs\",\n\"Diamonds\", or \"pass\" to either order up the specified suit or pass.\nThis procedure is the same for both rounds of making trump.\n\nSample output code:\n```c++\nprint_hand();\ncout << \"Human player \" << name << \", please enter a suit, or \\\"pass\\\":\\n\";\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Add a private member function that prints out the human player's hand.\n```c++\nvoid print_hand() const {\n  for (size_t i=0; i < hand.size(); ++i)\n    cout << \"Human player \" << name << \"'s hand: \"\n         << \"[\" << i << \"] \" << hand[i] << \"\\n\";\n}\n```\n</div>\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Use the `string_to_suit()` function provided with the starter code.\n```c++\nstring decision;\ncin >> decision;\n\nif (decision != \"pass\") {\n  Suit ordered_up = string_to_suit(decision);\n  ...\n}\nelse {\n  ...\n}\n```\n</div>\n\n#### Adding the Upcard and Discarding\n{:.primer-spec-toc-ignore}\n\nIf a Human Player is the dealer and someone orders up during the first\nround of making, the Human Player will pick up the upcard and discard\na card of their choice. Print the Player's hand and an option to\ndiscard the upcard. Then, prompt the user to select a card to discard.\nThe user will then enter the number corresponding to the card they\nwant to discard (or -1 if they want to discard the upcard).\n\nSample output code:\n```c++\nprint_hand();\ncout << \"Discard upcard: [-1]\\n\";\ncout << \"Human player \" << name << \", please select a card to discard:\\n\";\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Make \"sorted card ordering\" a _representation invariant_ of your Human Player class and ensure that the hand is always kept in sorted order.\nFor consistency with autograder test cases, the cards in a human player's hand must always be printed in ascending order, as defined by the `<` operator in `Card.hpp`.\n\nUse the STL to sort a `vector<Card> hand`:\n```c++\n#include <algorithm>\n// ...\nstd::sort(hand.begin(), hand.end());\n```\n{: data-variant=\"no-line-numbers\" }\n\n**Pitfall:** Using `sort` on a member variable in a `const` member function leads to a confusing error, `no matching function for call to 'swap'`.  Instead, call `sort` when adding a card to the `hand`.\n```c++\nvoid Human::print_hand() const {\n  std::sort(hand.begin(), hand.end()); // Error!\n  // ...\n}\n```\n</div>\n\n#### Playing and Leading Tricks\n{:.primer-spec-toc-ignore}\n\nWhen it is the Human Player's turn to lead or play a trick, first\nprint the Player's hand. Then, prompt the user to select a card. The user\nwill then enter the number corresponding to the card they want to\nplay.\n\nSample output code:\n```c++\nprint_hand();\ncout << \"Human player \" << name << \", please select a card:\\n\";\n```\n\n\n## Euchre Game\n\nWrite the Euchre Game in `euchre.cpp` following the [EECS 280 Euchre Rules](#eecs-280-euchre-rules).\n\nRun a Euchre game with four players.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n\n### Setup\nMake sure you have created `euchre.cpp` ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#add-new-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#add-new-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#add-new-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#add-new-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#touch)).\n\nAdd \"hello world\" code if you haven't already.\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n  cout << \"Hello World!\\n\";\n}\n```\n\nThe euchre program should compile and run.\n```console\n$ make euchre.exe\n$ ./euchre.exe\nHello World!\n```\n\nConfigure your IDE to debug the euchre program.\n\n<table>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/euchre.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/euchre.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `euchre.cpp`, `Card.cpp`, `Pack.cpp`, `Player.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `euchre.cpp`\n  - Exclude `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `main.cpp` (if present)\n  </td>\n</tr>\n</table>\n\nConfigure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)).  We recommend starting with the euchre test 00: `pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple`\n\nTo compile and run a Euchre game with four players.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n\n### Interface\n\nThe Euchre game driver takes several command line arguments, for example:\n\n```console\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each command line argument.\n\n| `./euchre.exe` | Name of the executable |\n| `pack.in` | Filename of the pack |\n| `noshuffle` | Don't shuffle the deck, or use `shuffle` to turn on shuffling |\n| `1` | Points to win the game |\n| `Adi` | Name of player 0 |\n| `Simple` | Type of player 0 |\n| `Barbara` | Name of player 1 |\n| `Simple` | Type of player 1 |\n| `Chi-Chih` | Name of player 2 |\n| `Simple` | Type of player 2 |\n| `Dabbala` | Name of player 3 |\n| `Simple` | Type of player 3 |\n\nCheck for each of these errors:\n  - There are exactly 12 arguments, including the executable name.\n  - Points to win the game is between 1 and 100, inclusive.\n  - The shuffle argument is either `shuffle` or `noshuffle`.\n  - The types of each of the players are either `Simple` or `Human`.\n\nIf there is an error print this message and no other output.  Exit returning a non-zero value from `main`.\n\n```c++\ncout << \"Usage: euchre.exe PACK_FILENAME [shuffle|noshuffle] \"\n     << \"POINTS_TO_WIN NAME1 TYPE1 NAME2 TYPE2 NAME3 TYPE3 \"\n     << \"NAME4 TYPE4\" << endl;\n```\n\nYou must also verify the pack input file opens successfully. If it does not,\nprint this error message and exit returning a non-zero value from `main`.\n\n```c++\n// Assume pack_filename is a variable containing\n// the specified pack filename from argv\ncout << \"Error opening \" << pack_filename << endl;\n```\n{: data-variant=\"no-line-numbers\" }\n\nIf the file opens successfully, you may assume it is formatted correctly.\n\n### Design\n\nThe Euchre game driver coordinates all the [actions in the game](#playing-the-game).  *Take some time* to design this complex piece of code before beginning.\n\nWe recommend writing a `Game` ADT. It should have a constructor that takes in details like the players, points to win, etc. and a public `play()` function.  The `Game` and its helper functions do the hard work, and the `main()` function is simple.\n\n```c++\nclass Game {\n public:\n  // primer-spec-highlight-start\n  Game(/* game details */);\n  void play();\n  // primer-spec-highlight-end\n};\n\nint main(int argc, char **argv) {\n  // Read command line args and check for errors\n  // primer-spec-highlight-start\n  Game game(/* game details */);\n  game.play();\n  // primer-spec-highlight-end\n}\n```\n\nNext, consider which member data you'll need.  Examples include player pointers, pack of cards, etc.\n```c++\nclass Game {\n public:\n  Game(/* ... */);\n  void play();\n\n private:\n  // primer-spec-highlight-start\n  std::vector<Player*> players;\n  Pack pack;\n  // ...\n  // primer-spec-highlight-end\n};\n```\n\nWhich helper functions would help simplify the `play()` function?  Add these as private member functions.  Functions that shuffle, deal, make trump, and play a hand are a good starting point. \n```c++\nclass Game {\n public:\n  Game(/* ... */);\n  void play();\n\n private:\n  std::vector<Player*> players;\n  Pack pack;\n  // ...\n\n  // primer-spec-highlight-start\n  void shuffle();\n  void deal(/* ... */);\n  void make_trump(/* ... */);\n  void play_hand(/* ... */);\n  // ...\n  // primer-spec-highlight-end\n};\n```\n\n#### End of game\n{: .primer-spec-toc-ignore }\n\nAt the end of a game, delete the `Player` objects created by the [`Player_factory`](#player-factory).\n\n```c++\nfor (size_t i = 0; i < players.size(); ++i) {\n  delete players[i];\n}\n```\n\n### Example With Simple Players\n\nWe've provided full example output for a game with four simple players in `euchre_test00.out.correct`.  This section explains the output line by line.\n\nAs a reminder, all the output in this example is produced by the Euchre Game driver, not by the simple player code in `Player.cpp`.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Debug differences in game output using `diff -y -B`, which shows differences side-by-side and ignores whitespace.  We'll use the `less` pager so we can scroll through the long terminal output.  Press `q` to quit.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple > euchre_test00.out\n$ diff -y -B euchre_test00.out.correct euchre_test00.out | less  # q to quit\n```\n</div>\n\nRun the example.\n\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n\nFirst, print the executable and all arguments on the first line. Print\na single space at the end, which makes it easier to print an array.\n\n```\n./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple \n```\n{: data-variant=\"legacy\" }\n\nAt the beginning of each hand, announce the hand, starting at zero,\nfollowed by the dealer and the upcard.\n\n```\nHand 0\nAdi deals\nJack of Diamonds turned up\n```\n{: data-variant=\"legacy\" }\n\nPrint the decision of each player during the making procedure. Print\nan extra newline when making, adding, and discarding is complete.\n\n```\nBarbara passes\nChi-Chih passes\nDabbala passes\nAdi passes\nBarbara orders up Hearts\n```\n{: data-variant=\"legacy\" }\n\nEach of the five tricks is announced, including the lead, cards played\nand the player that took the trick. Print an extra newline at the end\nof each trick.\n\n```\nJack of Spades led by Barbara\nKing of Spades played by Chi-Chih\nAce of Spades played by Dabbala\nNine of Diamonds played by Adi\nDabbala takes the trick\n\n```\n{: data-variant=\"legacy\" }\n\nAt the end of the hand, print the winners of the hand. When printing\nthe names of a partnership, print the player with the lower index\nfirst. For example, Adi was specified on the command line before\nChi-Chih, so he goes first.\n\n```\nAdi and Chi-Chih win the hand\n```\n{: data-variant=\"legacy\" }\n\nIf a march occurs, print `march!` followed by a newline. If euchre\noccurs, print `euchred!` followed by a newline. If neither occurs,\nprint nothing.\n\n```\neuchred!\n```\n{: data-variant=\"legacy\" }\n\nPrint the score, followed by an extra newline.\n\n```\nAdi and Chi-Chih have 2 points\nBarbara and Dabbala have 0 points\n```\n{: data-variant=\"legacy\" }\n\nWhen the game is over, print the winners of the game.\n\n```\nAdi and Chi-Chih win!\n```\n{: data-variant=\"legacy\" }\n\nThe output for a much longer game with four simple players is in `euchre_test01.out.correct`. See the [Euchre Test 01 Explanation](euchre_test01.html) for an explanation of the output.\n\n### Example With Human Players\n\nWeve provided full example output for a game with four human players in `euchre_test50.out.correct`. The input is in `euchre_test50.in`.  This section explains the output line by line.\n\nOutput that is specific to the Human Player should be printed by the Human Player code in (`Player.cpp`). All other output that is common to both Simple and Human Players should be printed by the Euchre Game driver.\n\nSet up input redirection ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#input-redirection), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#input-redirection), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#input-redirection), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#input-redirection)) to read `euchre_test50.in`. \n\nConfigure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)) for euchre test 50: `noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human`\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Similar to the simple player, you can debug differences in game output using `diff -y -B`.  Press `q` to quit.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human < euchre_test50.in > euchre_test50.out\n$ diff -y -B euchre_test50.out.correct euchre_test50.out | less  # q to quit\n```\n</div>\n\nRun the example, redirecting the input file `euchre_test50.in` to stdin.\n\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human < euchre_test50.in\n```\n\nFirst, print the executable and all arguments on the first line. Print\na single space at the end, which makes it easier to print an array.\n\n```\n./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human \n```\n{: data-variant=\"legacy\" }\n\nAt the beginning of each hand, announce the hand, starting at zero,\nfollowed by the dealer and the upcard.\n\n```\nHand 0\nIvan deals\nJack of Diamonds turned up\n```\n{: data-variant=\"legacy\" }\n\nPrint the hand of each player during the making procedure, followed by\na prompt for their making decision. End the prompt with a newline\nimmediately after the colon.\n\n```\nHuman player Judea's hand: [0] Nine of Spades\nHuman player Judea's hand: [1] Ten of Spades\nHuman player Judea's hand: [2] Jack of Spades\nHuman player Judea's hand: [3] King of Hearts\nHuman player Judea's hand: [4] Ace of Hearts\nHuman player Judea, please enter a suit, or \"pass\":\n```\n{: data-variant=\"legacy\" }\n\nPrint the decision of each player during the making procedure.\n\n```\nJudea passes\n...\nJudea orders up Hearts\n```\n{: data-variant=\"legacy\" }\n\nPrint the dealer's hand if a player orders up during the first round,\nas well as an option to discard the upcard. Prompt the dealer to\nselect a card to discard, ending the prompt with a newline immediately\nafter the colon. Print an extra newline when making, adding, and\ndiscarding is done.\n\n```\nHuman player Ivan's hand: [0] Nine of Diamonds\n...\nHuman player Ivan's hand: [4] Ace of Clubs\nDiscard upcard: [-1]\nHuman player Ivan, please select a card to discard:\n```\n{: data-variant=\"legacy\" }\n\nFor each trick, print the Human Player's hand and prompt them to\nselect a card.\n\n```\nHuman player Judea's hand: [0] Nine of Spades\n...\nHuman player Judea's hand: [4] Ace of Hearts\nHuman player Judea, please select a card:\n```\n{: data-variant=\"legacy\" }\n\nThen print the card played or lead.\n\n```\nNine of Spades led by Judea\n```\n{: data-variant=\"legacy\" }\n\nAt the end of each trick, print the player who took the trick as well\nas an extra newline.\n\n```\nLiskov takes the trick\n```\n{: data-variant=\"legacy\" }\n\nAt the end of the hand, print the winners of the hand. When printing\nthe names of a partnership, print the player with the lower index\nfirst. For example, Ivan was specified on the command line before\nKunle, so he goes first.\n\n```\nIvan and Kunle win the hand\n```\n{: data-variant=\"legacy\" }\n\nIf a march occurs, print `march!` followed by a newline. If euchre\noccurs, print `euchred!` followed by a newline. If neither occurs, print\nnothing.\n\n```\neuchred!\n```\n{: data-variant=\"legacy\" }\n\nPrint the score, followed by an extra newline.\n\n```\nIvan and Kunle have 2 points\nJudea and Liskov have 0 points\n```\n{: data-variant=\"legacy\" }\n\nWhen the game is over, print the winners of the game.\n\n```\nIvan and Kunle win!\n```\n{: data-variant=\"legacy\" }\n\n\n## Submission and Grading\n\nSubmit these files to the [autograder](https://autograder.io).\n  - `Card.cpp`\n  - `Card_tests.cpp`\n  - `Pack.cpp`\n  - `Player.cpp`\n  - `Player_tests.cpp`\n  - `euchre.cpp`\n\nYou do not have to submit `Pack_tests.cpp` to the autograder.\n\nThis project will be autograded for correctness, comprehensiveness of\nyour test cases, and programming style. See the [style checking\ntutorial](https://eecs280staff.github.io/tutorials/setup_style.html)\nfor the criteria and how to check your style automatically on CAEN.\n\n### Checkpoint\n\nThis project is graded on an early checkpoint as well as the full submission. The checkpoint submission is worth 0.5% of your overall course grade. The full submission is worth 9.5% of your overall course grade.\n\nThe checkpoint consists of everything except the [Euchre Game](#euchre-game) driver.\n\nSubmit these files to the [autograder](https://autograder.io).\n  - `Card.cpp`\n  - `Card_tests.cpp`\n  - `Pack.cpp`\n  - `Player.cpp`\n  - `Player_tests.cpp`\n\nThere are no private tests and no style grading at the checkpoint.\n\nYour checkpoint score does not change after the checkpoint deadline, even though we run the same public tests and [mutation tests](#unit-test-grading) at both the checkpoint and full submission.\n\nAfter the checkpoint autograder closes, the full submission autograder will open.\n\n### Testing\n\nRun all the unit tests and system tests.  This includes the public tests we provided and the unit tests that you wrote.\n\n```console\n$ make test\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Run commands in parallel with `make -j`.\n```console\n$ make -j4 test\n```\n{: data-variant=\"no-line-numbers\" }\n</div>\n\n### Unit Test Grading\n\nWe will autograde your `Card_tests.cpp` and `Player_tests.cpp` unit tests. Note that your player tests should only test the \"simple player\", not the \"human player\".\n\nYour unit tests must use the [unit test framework](https://eecs280staff.github.io/unit_test_framework/).\n\nA test suite must run in less than 5 seconds and contain 50 or fewer `TEST()` functions.  One test suite is one `_tests.cpp` file.\n\nTo grade your unit tests, we use a set of intentionally buggy instructor solutions.  You get points for catching the bugs.\n\n1.  We compile and run your unit tests with a **correct solution**.\n    - Tests that pass are **valid**.\n    - Tests that fail are **invalid**, they falsely report a bug.\n3.  We compile and run all of your **valid** tests against each **buggy solution**.\n    - If any of your tests fail, you caught the bug.\n    - You earn points for each bug that you catch.\n\n### Requirements and Restrictions\n\nIt is our goal for you to gain practice with good C++ code, classes,\nand polymorphism.\n\n\n| DO | DO NOT |\n| -- | ------ |\n| Modify `.cpp` files | Modify `.hpp` files |\n| Write helper functions in `Card.cpp` and `Pack.cpp` as non-member functions in the `.cpp` files and declare them `static` | Modify `.hpp` files |\n| Use these libraries: `<iostream>`, `<fstream>`, `<cstdlib>`, `<cassert>`, `<cstring>`, `<string>`, `<array>`, `<vector>`, `<sstream>` <br>Use the `<algorithm>` library, but only for the `sort()` function. | Use other libraries. <br><br>Use `<algorithm>` library for anything other than the `sort()` function. |\n| `#include` a library to use its functions | Assume that the compiler will find the library for you (some do, some don't) |\n| | `#include` an unnecessary `.hpp` file, such as `#include Pack.hpp` in either `Card.cpp` or in `Player.cpp` (This introduces undesirable dependencies, e.g. that the `Card`/`Player` ADTs require the `Pack` ADT to exist and be properly implemented.) |\n| Use C++ strings | Use C-strings other than when checking `argv` |\n| Send all output to standard out (AKA stdout) by using `cout` | Send any output to standard error (AKA stderr) by using `cerr` |\n| `const` global variables | Global or static variables |\n| Pass large structs or classes by reference | Pass large structs or classes by value |\n| Pass by `const` reference when appropriate | \"I don't think I'll modify it ...\" |\n| Variables on the stack | Dynamic memory (`new`, `malloc()`, etc.) outside of the `Player_factory`. |\n\n\n## Acknowledgments\n\nThe original project was written by Andrew DeOrio, Fall 2013. The\nproject was modified to use C++ style object oriented programming and\nthe specification updated by the Fall 2015 staff."
  },
  "doc-cbbfc3f9b8395ed4ec17ee7373803914": {
    "content": "---\nlayout: spec\nmermaid: true\n---\n\nEECS 280 Project 3: Euchre\n==========================\n{: .primer-spec-toc-ignore }\n\nWinter 2025 release.\n\nCheckpoint due 8:00pm EST Monday February 24, 2025.  See [Submission and Grading / Checkpoint](#checkpoint).\n\nFull project due 8:00pm EST Wednesday March 12, 2025.\n\nYou may work alone or with a partner ([partnership guidelines](https://eecs280.org/syllabus.html#project-partnerships)). If you work alone, you must work alone on both the checkpoint and the full project. If you work with a partner, you must work with the same partner on the checkpoint and the full project. You may not work alone on the checkpoint and then add a partner for the full project.\n\n<!--\n## Change Log\n\n-->\n\n## Introduction\nEuchre (pronounced \"YOO-kur\") is a card game popular in Michigan.\n\nThe learning goals of this project include Abstract Data Types in C++, Derived Classes, Inheritance, and Polymorphism.  You'll gain practice with C++-style Object Oriented Programming (OOP) with classes and virtual functions.\n\nWhen you're done, you'll have a program that simulates a game of Euchre, supporting a AI player and a Human player.\n```console\n$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Simple Kunle Simple Liskov Simple\nHand 0\nIvan deals\nJack of Diamonds turned up\nJudea passes\nKunle passes\nLiskov passes\nHuman player Ivan's hand: [0] Nine of Diamonds\nHuman player Ivan's hand: [1] Ten of Diamonds\nHuman player Ivan's hand: [2] Jack of Hearts\nHuman player Ivan's hand: [3] Queen of Hearts\nHuman player Ivan's hand: [4] Ace of Clubs\nHuman player Ivan, please enter a suit, or \"pass\":\nDiamonds\nIvan orders up Diamonds\n...\n```\n{: data-variant=\"legacy\" }\n\n\n## Setup\nSet up your visual debugger and version control, then submit to the autograder.\n\n### Visual debugger\nDuring setup, name your project `p3-euchre`. Use this starter files link: `https://eecs280staff.github.io/euchre/starter-files.tar.gz`\n\n| [VS Code](https://eecs280staff.github.io/tutorials/setup_vscode.html)| [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html) | [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html) |\n\nIf you created a `main.cpp` while following the setup tutorial, rename it to `euchre.cpp`. Otherwise, create a new file `euchre.cpp`.  You should end up with a folder with starter files that looks like this.  You may have already renamed files like `Card.cpp.starter` to `Card.cpp`.\n```console\n$ ls\nCard.cpp.starter        Pack_public_tests.cpp     euchre_test00.out.correct\nCard.hpp                Pack_tests.cpp.starter    euchre_test01.out.correct\nCard_public_tests.cpp   Player.hpp                euchre_test50.in\nCard_tests.cpp.starter  Player_public_tests.cpp   euchre_test50.out.correct\nMakefile                Player_tests.cpp.starter  pack.in\nPack.hpp                euchre.cpp                unit_test_framework.hpp\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each starter file.\n\n| File(s) | Description |\n| ------- | ----------- |\n| `Card.hpp` | Abstraction representing a playing card. |\n| `Card.cpp.starter` | Starter code for the `Card`. |\n| `Card_tests.cpp` | Your `Card` unit tests. |\n| `Card_public_tests.cpp` | Compile check test for `Card.cpp`. |\n| `Pack.hpp` | Abstraction representing a pack cards. |\n| `Pack_tests.cpp` | Add your `Pack` unit tests to this file. |\n| `Pack_public_tests.cpp` | Compile check test for `Pack.cpp`. |\n| `Player.hpp` | Abstraction representing a euchre player. |\n| `Player_tests.cpp` | Your `Player` unit tests. |\n| `Player_public_tests.cpp` | Compile check test for `Player.cpp`. |\n| `pack.in` | Input file containing a Euchre deck. |\n| `Makefile` | Helper commands for building. |\n| `euchre_test00.out.correct` <br>`euchre_test01.out.correct` | Correct output for system tests with Simple player.  |\n| `euchre_test50.in` <br>`euchre_test50.out.correct` | Input and correct output for system tests with Human player. |\n| `unit_test_framework.hpp` | A simple unit-testing framework. |\n\n### Version control\nSet up version control using the [Version control tutorial](https://eecs280staff.github.io/tutorials/setup_git.html).\n\nAfter you're done, you should have a local repository with a \"clean\" status and your local repository should be connected to a remote GitHub repository.\n```console\n$ git status\nOn branch main\nYour branch is up-to-date with 'origin/main'.\n\nnothing to commit, working tree clean\n$ git remote -v\norigin\thttps://github.com/awdeorio/p3-euchre.git (fetch)\norigin\thttps://githubcom/awdeorio/p3-euchre.git (push)\n```\n\nYou should have a `.gitignore` file ([instructions](https://eecs280staff.github.io/tutorials/setup_git.html#add-a-gitignore-file)).\n```console\n$ head .gitignore\n# This is a sample .gitignore file that's useful for C++ projects.\n...\n```\n\n### Group registration\nRegister your partnership (or working alone) on the  [Autograder](https://autograder.io/).  Then, submit the code you have.\n\n## EECS 280 Euchre Rules\n\nThere are many variants of Euchre. Our particular version is based on\na variety commonly played in Michigan with a few changes to make it\nfeasible as a coding project.\n\nOur step-by-step explanation of a game of \"EECS 280 Euchre\" can be found in a [YouTube video](https://www.youtube.com/watch?v=M0jGJ0NRcrc) and a [PDF](https://drive.google.com/file/d/14MSt1WdtnRbfgpPiMp9YuKn2wQ4Z83Ir/view?usp=sharing).\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Skim this section the first time through.  Refer back to it while you're coding.\n</div>\n\n### Players\n{:.primer-spec-toc-ignore}\n\nThere are four players numbered 0-3. If the players sat around the\ntable, it would look like this:\n\n![](images/image2.png){: .invert-colors-in-dark-mode }\n\nThere are two teams: players 0 and 2 are *partners*, as are 1 and 3.\nEach player has left and right *neighbors*. For example, 1 is to the\nleft of 0, and 3 is to the right of 0. That means 1 is 0's left\n*neighbor*, and 3 is 0's right *neighbor*.\n\n### The Cards\n{:.primer-spec-toc-ignore}\n\nEuchre uses a deck of 24 *playing cards*, each of which has two\nproperties: a *rank* and a *suit*. The ranks are 9, 10, *Jack*,\n*Queen*, *King*, and *Ace*, and the suits are *Spades*, *Hearts*,\n*Clubs*, and *Diamonds*. Each card is unique &mdash; there are no duplicates.\nThroughout this document, we sometimes refer to ranks or suits using\nonly the first letter of their name. Farther below, we describe how to\ndetermine the [ordering of the cards](#value-of-cards).\n\n### Playing the Game\n\nAt a high level, a game of Euchre involves several rounds, which are\ncalled *hands*. Each hand consists of the following phases.\n\nEach hand:\n\n1.  [Setup table](#setup-table)\n    1.  [Shuffle](#shuffle)\n    2.  [Deal](#deal)\n2.  [Making Trump](#making-trump)\n    1.  [Round One](#round-one)\n    2.  [Round Two](#round-two)\n3.  [Trick Taking](#trick-taking)\n4.  [Scoring](#scoring)\n\nWe describe each in more detail below.\n\n### Setup table\n\n#### Shuffle\n{:.primer-spec-toc-ignore}\n\nThe dealer shuffles the deck at the beginning of each hand. The\nalgorithm you will implement for shuffling is a variant of a riffle\nshuffle called an \"in shuffle\"\n([https://en.wikipedia.org/wiki/In\\_shuffle](https://en.wikipedia.org/wiki/In_shuffle)).\nCut the deck exactly in half and then interleave the two halves,\nstarting with the second half. Thus, the card originally at position\n12 goes to position 0, the one originally at position 0 goes to\nposition 1, the one originally at position 13 goes to position 2, and\nso on. Do this in-shuffle process 7 times.\n\nYou will also implement an option to run the game with shuffling\ndisabled - when this option is chosen, just reset the pack any time\nshuffling would be called for. This may make for easier testing and\ndebugging.\n\n#### Deal\n{:.primer-spec-toc-ignore}\n\nIn each hand, one player is designated as the *dealer* (if humans were\nplaying the game, the one who passes out the cards). In our game,\nplayer 0 deals during the first hand. Each subsequent hand, the role\nof dealer moves one player to the left.\n\nEach player receives five cards, dealt in alternating batches of 3 and 2.\nThat is, deal 3-2-3-2 cards then 2-3-2-3 cards, for a total of 5\ncards each. The player to the left of the dealer receives the first\nbatch, and dealing continues to the left until 8 batches have been\ndealt.\n\nFour cards remain in the deck after the deal. The next card in the\npack is called the upcard (it is turned face up, while the other cards\nare all face down). It plays a special role in the next phase. The\nthree remaining cards are not used for the current hand.\n\n### Making Trump\n\nDuring this phase, the trump suit is determined by whichever player\nchooses to *order up*.\n\n#### Round One\n{:.primer-spec-toc-ignore}\n\nThe suit of the *upcard* is used to propose a *trump* suit whose cards\nbecome more valuable during the upcoming hand. Players are given the\nopportunity to *order up* (i.e. select the suit of the upcard to be\nthe trump suit) or *pass*, starting with the player to the dealer's\nleft (also known as the *eldest hand*) and progressing once around the\ncircle to the left. If any player orders up, the upcard's suit becomes\ntrump and the dealer is given the option to replace one of their cards\nwith the upcard.\n\n#### Round Two\n{:.primer-spec-toc-ignore}\n\nIf all players *pass* during the first round, there is a second round\nof *making*, again beginning with the eldest hand. The upcard's suit\nis rejected and cannot be ordered up. Instead, the players may *order\nup* any suit other than the upcard's suit. The dealer does not have\nthe opportunity to pick up the upcard during round two.\n\nIf *making* reaches the dealer during the second round, a variant\ncalled *screw the dealer* is invoked: the dealer must order up a suit\nother than the rejected suit.\n\n(Note for pro Euchre players: for simplicity, we have omitted \"going\nalone\" in this version.)\n\n### Trick Taking\n\nOnce the trump has been determined, five *tricks* are played. For each\ntrick, players take turns laying down cards, and whoever played the\nhighest card *takes* the trick.\n\nDuring each trick, the player who plays first is called the *leader*.\nFor the first trick, the eldest hand leads.\n\nAt the beginning of each trick, the leader *leads* a card, which\naffects which cards other players are allowed to play, as well as the\nvalue of each card played (see below). Each other player must *follow\nsuit* (play a card with the same suit as the led card) if they are\nable, and otherwise may play any card (it is removed from their hand).\nPlay moves to the left around the table, with each player playing one\ncard.\n\nA trick is won by the player who played the highest valued card (see\nbelow to determine comparative values). The winner of the trick\n*leads* the next one.\n\n### Scoring\n\nThe team that takes the majority of tricks receives points for that hand.\n* If the team that ordered up the trump suit takes 3 or 4 tricks, they get 1 point.\n* If the team that ordered up the trump suit takes all 5 tricks, they get 2 points. This is called a *march*.\n* If the team that did not order up takes 3, 4, or 5 tricks, they receive 2 points. This is called *euchred*.\n\nTraditionally, the first side to reach 10 points wins the game. In\nthis project, the number of points needed to win is specified when the\nprogram is run.\n\n### Value of cards\n\nIn order to determine which of two cards is better, you must pay\nattention to the context in which they are being compared. There are\nthree separate contexts, which depend on whether or not a trump or led\nsuit is present.\n\nIn the simplest case, cards are ordered by rank (A \\> K \\> Q \\> J \\>\n10 \\> 9), with ties broken by suit (D \\> C \\> H \\> S).\n\nIf a *trump suit* is present, all trump cards are more valuable than\nnon-trump cards. That means a 9 of the trump suit will beat an Ace of\na non-trump suit. Additionally, two special cards called *bowers* take\non different values than normal.\n\n  - *Right Bower*: The Jack of the trump suit. This is the most\n    valuable card in the game.\n  - *Left Bower*: The Jack of the \"same color\" suit as trump is\n    **considered to be a trump** (regardless of the suit printed on\n    the card) and is the second most valuable card.\n\nThe suit of the left bower is called *next*, while the two suits of the opposite color are called *cross* suits.\n\nIf a *led suit* is present as well as a trump suit, the ordering is\nthe same except that all cards of the led suit are considered more\nvaluable than all non-trump-suit, non-led-suit cards. Note that it is\npossible for the trump suit and led suit to be the same.\n\n<div class=\"primer-spec-callout warning\" markdown=\"1\">\n**Pitfall:** The left bower is always considered the trump suit.  For example, if Diamonds is trump, the Jack of Hearts is also considered a Diamond, not a Heart.\n</div>\n\n![](images/image1.png)\n\nThe above shows card orderings in the possible contexts. Cards in\nhigher rows are greater than those in lower rows. Within rows, cards\nfarther to the left are greater. Note the right bower (blue outline)\nand left bower (red outline).\n\n### Euchre Glossary\n\n**Trump:** A suit whose cards are elevated above their normal rank\nduring play.\n\n**Right Bower:** The Jack card of the *Trump* suit, which is\nconsidered the highest-valued card in Euchre.\n\n**Left Bower:** The Jack from the other suit of the same color as the\n*Trump* suit, considered the second highest-valued card in Euchre. The\n*Left Bower* is also considered a *Trump* card.\n\n**Face or Ace:** The Jack, Queen, and King cards are generally pictured with people on them and are called \"face\" cards. These and the ace cards are more powerful than the 9 or 10 and factor into the simple player's strategy.\n\n**Next Suit:** The suit of the same color as trump.\n\n**Cross Suits:** The two suits of the opposite color as trump.\n\n**Making:** The process in which a trump card is chosen, consists of\ntwo rounds.\n\n**Eldest:** Player to the left of the dealer.\n\n**Upcard:** The up-facing card in front of the dealer that proposes\nthe trump suit.\n\n**Order Up:** Accepts the *Upcard* suit.\n\n**Pass:** Player rejects the suit and passes on the decision to the\nnext player.\n\n**Screw the Dealer:** When making* reaches the dealer on round two,\n*the dealer must *order up* a suit other than the rejected one.\n\n**Lead:** The first card played by the eldest* hand, regardless of who\n*is the maker.\n\n**Leader:** Person playing the lead* card in a trick, allowed to lead*\n*any card.\n\n**March:** When the side that made trump* wins all 5 tricks.\n\n**Euchred:** When the side that didn't make trump* wins 3, 4, or 5\n*tricks.\n\n\n## Card\n\nWrite an abstract data type (ADT) for a playing card.  Refer back to the [Value of cards section](#value-of-cards) while you're working on the card ADT.\n\nBefore getting started, take a look at the [Operator Overloading Tutorial](operator_overloading.html).  That will help you understand functions like:\n```c++\nbool operator<(const Card &lhs, const Card &rhs);\n```\n\nNext, see the short [Enumerated Type Tutorial](enum.html).  It explains code like this from `Card.hpp`.\n```c++\nenum Suit {\n  SPADES   = 0,\n  HEARTS   = 1,\n  CLUBS    = 2,\n  DIAMONDS = 3,\n};\n```\n\nWrite implementations in `Card.cpp` for the functions declared in\n`Card.hpp`.\n\nRun the public Card tests.\n```console\n$ make Card_public_tests.exe\n$ ./Card_public_tests.exe\n```\n\nWrite tests for `Card` in `Card_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make Card_tests.exe\n$ ./Card_tests.exe\n```\n\nSubmit `Card.cpp` and `Card_tests.cpp` to the [autograder](https://autograder.io).\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Compare the underlying numeric representation of an `enum`.\n```c++\nRank r = JACK;\nr == JACK; // true\n\nSuit s1 = SPADES;\nSuit s2 = DIAMONDS;\ns1 < s2;  // true\n```\n</div>\n\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Card.cpp.starter` -> `Card.cpp`\n-  `Card_tests.cpp.starter` -> `Card_tests.cpp`\n\nEdit `Card.cpp`, adding a function stub for each of the Card member functions in `Card.hpp`.\n```c++\nCard::Card() {\n  assert(false);\n}\n```\n{: data-title=\"Card.cpp\" }\n\nEdit `Card.cpp`, adding  function stubs for each of the non-member non-operator functions in `Card.hpp`.  Here are a few examples.\n```c++\nSuit Suit_next(Suit suit) {\n  assert(false);\n}\n\nbool Card_less(const Card &a, const Card &b, Suit trump) {\n  assert(false);\n}\n```\n{: data-title=\"Card.cpp\" }\n\nEdit `Card.cpp`, adding  function stubs for each of the overloaded operators in `Card.hpp`.  Here are a few examples.\n```c++\nstd::ostream & operator<<(std::ostream &os, const Card &card) {\n  assert(false);\n}\n\nbool operator<(const Card &lhs, const Card &rhs) {\n  assert(false);\n}\n\n```\n{: data-title=\"Card.cpp\" }\n\nThe Card tests should compile and run.  Expect them to fail at this point because the `Card.cpp` starter code contains function stubs.\n```console\n$ make Card_public_tests.exe\n$ ./Card_public_tests.exe\n$ make Card_tests.exe\n$ ./Card_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Card_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Card_public_tests.cpp`, `Card.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Card_tests.cpp`, `Card.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Card_public_tests.cpp`\n  - Exclude `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Card_tests.cpp`\n  - Exclude `Card_public_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Testing\nThis section contains a few tips for writing your own tests in `Card_tests.cpp`.\n\nHere's how to create a Card and check its rank and suit.\n```c++\nCard ace_hearts(ACE, HEARTS);\nASSERT_EQUAL(ace_hearts.get_rank(), ACE);\nASSERT_EQUAL(ace_hearts.get_suit(), HEARTS);\n```\n\nIn this example, the overloaded less-than operator runs: `bool operator<(const Card &lhs, const Card &rhs);`.  Notice that the suits are ordered to break ties (see the [Value of Cards](#value-of-cards) section).\n```c++\nCard ace_hearts(ACE, HEARTS);\nCard ace_diamonds(ACE, DIAMONDS);\nASSERT_TRUE(ace_hearts < ace_diamonds);\n```\n\n## Pack\n\nWrite an abstract data type (ADT) for a pack of playing cards.\n\nWrite implementations in `Pack.cpp` for the functions declared in\n`Pack.hpp`.\n\nRun the public Pack tests.\n```console\n$ make Pack_public_tests.exe\n$ ./Pack_public_tests.exe\n```\n\nWrite tests for `Pack` in `Pack_tests.cpp` using the unit test framework. While you should write your own tests for `Pack` to ensure that your implementation is correct, you do not have to submit your tests to the autograder.\n```console\n$ make Pack_tests.exe\n$ ./Pack_tests.exe\n```\n\nSubmit `Pack.cpp` to the [autograder](https://autograder.io).  Don't forget to include the code you finished earlier, `Card.cpp` and `Card_tests.cpp`.\n\n### Default constructor\n{: .primer-spec-toc-ignore }\n\nThe default `Pack` constructor initializes a full pack with cards in order from lowest to highest.\n```c++\nPack();\n```\n\nYou can take advantage of an `enum`'s underlying integer representation to loop over all its values.\n```c++\nfor (int s = SPADES; s <= DIAMONDS; ++s) {\n  Suit suit = static_cast<Suit>(s);\n}\n```\n\n### Stream input constructor\n{: .primer-spec-toc-ignore }\n\nA second `Pack` constructor reads a pack from stream input. [Later](#command-line-arguments), your `main` function will open an input file and then call this constructor on the input stream.\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Pack_tests.cpp.starter` -> `Pack_tests.cpp`\n\nCreate a new file `Pack.cpp`.  Add a function stub for every function prototype in `Pack.hpp`.  Remember to `#include \"Pack.hpp\"`.\n\nFor example:\n```c++\n#include \"Pack.hpp\"\nvoid Pack::reset() {\n  assert(false);\n  assert(next); // DELETEME: avoid error \"private field is not used\"\n}\n```\n{: data-title=\"Pack.cpp\" }\n\nThe Pack tests should compile and run.  Expect them to fail at this point because the `Pack.cpp` contains function stubs.\n```console\n$ make Pack_public_tests.exe\n$ ./Pack_public_tests.exe\n$ make Pack_tests.exe\n$ ./Pack_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Pack_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Pack_public_tests.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Pack_tests.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Pack_public_tests.cpp`\n  - Exclude `Pack_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Pack_tests.cpp`\n  - Exclude `Pack_public_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Reading the Pack\n\nOne of the `Pack` constructors reads a pack from stream input. [Later](#interface), your `main` function will open an input file and then call this constructor on the input stream.\n```c++\nPack(std::istream& pack_input);\n```\n{: data-title=\"Pack.hpp\" }\n\nThe `pack.in` file provided with the project contains an example of the input format, with cards listed in \"new pack\" order:\n\n```\nNine of Spades\nTen of Spades\nJack of Spades\n...\nQueen of Diamonds\nKing of Diamonds\nAce of Diamonds\n```\n{: data-title=\"pack.in\" data-variant=\"no-line-numbers\" }\n\nYour implementation may assume any pack input is formatted correctly, with exactly 24\nunique and correctly formatted cards.\n\n## Player\n\nWe'll implement two players: a simple AI player and a human-controlled player that reads instructions from standard input (`cin`).  We have provided an abstract base class in `Player.hpp`.\n\n### Setup\nRename these files ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#rename-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#rename-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#rename-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#rename-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#mv)):\n-  `Player_tests.cpp.starter` -> `Player_tests.cpp`\n\nCreate a new file `Player.cpp`.  Add function stubs for the two \"vanilla\" functions in `Player.hpp`. Remember to `#include \"Player.hpp\"`. Later, you'll add new classes and member functions using derived classes, which you can ignore for now.\n```c++\n#include \"Player.hpp\"\nPlayer * Player_factory(const std::string &name, const std::string &strategy) {\n  assert(false);\n}\n\nstd::ostream & operator<<(std::ostream &os, const Player &p) {\n  assert(false);\n}\n```\n{: data-title=\"Player.cpp\" }\n\nThe Player tests should compile and run.  Expect them to fail at this point because the `Player.cpp` contains function stubs.\n```console\n$ make Player_public_tests.exe\n$ ./Player_public_tests.exe\n$ make Player_tests.exe\n$ ./Player_tests.exe\n```\n\nConfigure your IDE to debug either the public tests or your own tests.\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th>\n  Public tests\n  </th>\n  <th>\n  Your own tests\n  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_public_tests.exe`\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/Player_tests.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Player_public_tests.cpp`, `Player.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `Player_tests.cpp`, `Player.cpp`, `Pack.cpp`, `Card.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Player_public_tests.cpp`\n  - Exclude `Player_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `Player_tests.cpp`\n  - Exclude `Player_public_tests.cpp`, `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `euchre.cpp` (if present), `main.cpp` (if present)\n  </td>\n</tr>\n</tbody>\n</table>\n\n### Player factory\n\nSince the specific types of Players are hidden inside `Player.cpp`, we\nneed to write a *factory function* that returns a pointer to a\n`Player` with the correct dynamic type. We also need the pointed-to\nobjects to stick around after the factory function finishes, so we'll\ncreate the players using *dynamically allocated memory*. The prototype\nfor `Player_factory` can be found in `Player.hpp`, and the\nimplementation will go in `Player.cpp`.\n\n```c++\nPlayer * Player_factory(const std::string &name, \n                        const std::string &strategy) {\n  // We need to check the value of strategy and return \n  // the corresponding player type.\n  if (strategy == \"Simple\") {\n    // The \"new\" keyword dynamically allocates an object.\n    return new SimplePlayer(name);\n  }\n  // Repeat for each other type of Player\n  ...\n  // Invalid strategy if we get here\n  assert(false);\n  return nullptr;\n}\n```\n{: data-title=\"Player.cpp\" }\n\n### Simple Player\n\nImplement the Simple Player in `Player.cpp` by creating a class that derives from our `Player` abstract base class.  Override each Player function in `Player.cpp` for the functions declared in `Player.hpp`. \n\nMuch of the strategy for our Simple Player can be implemented using\nthe comparison functions provided by the Card interface.\n\nThe Simple Player should not print any output.\n\nRun the public Simple Player tests.\n```console\n$ make Player_public_tests.exe\n$ ./Player_public_tests.exe\n```\n\nWrite tests for the Simple Player in `Player_tests.cpp` using the [Unit Test Framework](https://eecs280staff.github.io/unit_test_framework/).  You'll submit these tests to the autograder.  See the [Unit Test Grading](#unit-test-grading) section.\n```console\n$ make Player_tests.exe\n$ ./Player_tests.exe\n```\n\nSubmit `Player.cpp` and `Player_tests.cpp` to the [autograder](https://autograder.io).  Don't forget to include the code you finished earlier, `Card.cpp`, `Card_tests.cpp`, and `Pack.cpp`.\n\n#### Making\n{:.primer-spec-toc-ignore}\n\nIn making trump, a Simple Player considers the upcard, which player\ndealt, and whether it is the first or second round of making trump. A\nmore comprehensive strategy would consider the other players'\nresponses, but we will keep it simple.\n\nDuring round one, a Simple Player considers ordering up the suit\nof the upcard, which would make that suit trump. They will order up if\nthat would mean they have two or more cards that are either face or ace\ncards of the trump suit (the right and left bowers, and Q, K, A of\nthe trump suit, which is the suit proposed by the upcard). (A Simple\nPlayer does not consider whether they are the dealer and could gain an\nadditional trump by picking up the upcard.)\n\nDuring round two, a Simple Player considers ordering up the suit with\nthe same color as the upcard, which would make that suit trump. They\nwill order up if that would mean they have one or more cards that are either\nface or ace cards of the trump suit in their hand (the right and left bowers, and Q, K, A of the order-up\nsuit). For example, if the upcard is a Heart and the player has the\nKing of Diamonds in their hand, they will order up Diamonds. The\nSimple Player will not order up any other suit. If making reaches the\ndealer during the second round, we invoke *screw the dealer*, where\nthe dealer is forced to order up. In the case of screw the dealer, the\ndealer will always order up the suit with the same color as the\nupcard.\n\n#### Adding the Upcard and Discarding a Card\n{:.primer-spec-toc-ignore}\n\nIf the trump suit is ordered up during round one, the dealer picks up\nthe upcard. The dealer then discards the lowest card in their hand,\neven if this is the upcard, for a final total of five cards. (Note that\nat this point, the trump suit is the suit of the upcard.)\n\n#### Leading Tricks\n{:.primer-spec-toc-ignore}\n\nWhen a Simple Player leads a trick, they play the highest non-trump\ncard in their hand. If they have only trump cards, they play the\nhighest trump card in their hand.\n\n#### Playing Tricks\n{:.primer-spec-toc-ignore}\n\nWhen playing a card, Simple Players use a simple strategy that\nconsiders only the suit that was led. A more complex strategy would\nalso consider the cards on the table.\n\nIf a Simple Player can follow suit, they play the highest card that\nfollows suit. Otherwise, they play the lowest card in their hand.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Here's a nice way to remove a Card from a vector using [`vector::erase`](https://cplusplus.com/reference/vector/vector/erase/).\n```c++\nvector<Card> hand;  // Assume hand is full of cards\nhand.erase(hand.begin() + i);  // Remove card i\n```\n</div>\n\n### Human Player\n\nThe Human Player reads input from the human user. You may assume all\nuser input is correctly formatted and has correct values. You may also\nassume the user will follow the rules of the game and not try to\ncheat. See [Example With Human Players](#example-with-human-players) for\nexact output for a game with a human player.\n\nImplement the Human Player in `Player.cpp` by creating a class that derives from our `Player` abstract base class.  Override each Player function in `Player.cpp` for the functions declared in `Player.hpp`. \n\nThe tests in `Player_tests.cpp` and `Player_public_tests.cpp` test only the Simple Player.  You'll have to wait until you have a working Euchre game driver to test the Human player.\n\nSubmit `Player.cpp` again to the [autograder](https://autograder.io).  Don't forget to include the code you finished earlier, `Card.cpp`, `Card_tests.cpp`, `Pack.cpp`, and `Player_tests.cpp`.\n\n#### Making Trump\n{:.primer-spec-toc-ignore}\n\nWhen making trump reaches a Human Player, first print the Player's\nhand. Then, prompt the user for their decision to pass or order up. The user will\nthen enter one of the following: \"Spades\", \"Hearts\", \"Clubs\",\n\"Diamonds\", or \"pass\" to either order up the specified suit or pass.\nThis procedure is the same for both rounds of making trump.\n\nSample output code:\n```c++\nprint_hand();\ncout << \"Human player \" << name << \", please enter a suit, or \\\"pass\\\":\\n\";\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Add a private member function that prints out the human player's hand.\n```c++\nvoid print_hand() const {\n  for (size_t i=0; i < hand.size(); ++i)\n    cout << \"Human player \" << name << \"'s hand: \"\n         << \"[\" << i << \"] \" << hand[i] << \"\\n\";\n}\n```\n</div>\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Use the `string_to_suit()` function provided with the starter code.\n```c++\nstring decision;\ncin >> decision;\n\nif (decision != \"pass\") {\n  Suit ordered_up = string_to_suit(decision);\n  ...\n}\nelse {\n  ...\n}\n```\n</div>\n\n#### Adding the Upcard and Discarding\n{:.primer-spec-toc-ignore}\n\nIf a Human Player is the dealer and someone orders up during the first\nround of making, the Human Player will pick up the upcard and discard\na card of their choice. Print the Player's hand and an option to\ndiscard the upcard. Then, prompt the user to select a card to discard.\nThe user will then enter the number corresponding to the card they\nwant to discard (or -1 if they want to discard the upcard).\n\nSample output code:\n```c++\nprint_hand();\ncout << \"Discard upcard: [-1]\\n\";\ncout << \"Human player \" << name << \", please select a card to discard:\\n\";\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Make \"sorted card ordering\" a _representation invariant_ of your Human Player class and ensure that the hand is always kept in sorted order.\nFor consistency with autograder test cases, the cards in a human player's hand must always be printed in ascending order, as defined by the `<` operator in `Card.hpp`.\n\nUse the STL to sort a `vector<Card> hand`:\n```c++\n#include <algorithm>\n// ...\nstd::sort(hand.begin(), hand.end());\n```\n{: data-variant=\"no-line-numbers\" }\n\n**Pitfall:** Using `sort` on a member variable in a `const` member function leads to a confusing error, `no matching function for call to 'swap'`.  Instead, call `sort` when adding a card to the `hand`.\n```c++\nvoid Human::print_hand() const {\n  std::sort(hand.begin(), hand.end()); // Error!\n  // ...\n}\n```\n</div>\n\n#### Playing and Leading Tricks\n{:.primer-spec-toc-ignore}\n\nWhen it is the Human Player's turn to lead or play a trick, first\nprint the Player's hand. Then, prompt the user to select a card. The user\nwill then enter the number corresponding to the card they want to\nplay.\n\nSample output code:\n```c++\nprint_hand();\ncout << \"Human player \" << name << \", please select a card:\\n\";\n```\n\n\n## Euchre Game\n\nWrite the Euchre Game in `euchre.cpp` following the [EECS 280 Euchre Rules](#eecs-280-euchre-rules).\n\nRun a Euchre game with four players.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n\n### Setup\nMake sure you have created `euchre.cpp` ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#add-new-files), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#add-new-files), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#add-new-files),  [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#add-new-files), [CLI](https://eecs280staff.github.io/tutorials/cli.html#touch)).\n\nAdd \"hello world\" code if you haven't already.\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n  cout << \"Hello World!\\n\";\n}\n```\n\nThe euchre program should compile and run.\n```console\n$ make euchre.exe\n$ ./euchre.exe\nHello World!\n```\n\nConfigure your IDE to debug the euchre program.\n\n<table>\n<tr>\n  <td>\n  <b>VS Code (macOS)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/euchre.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>VS Code (Windows)</b>\n  </td>\n  <td markdown=\"1\">\n  Set [program name](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#edit-launchjson-program) to: <br>\n  `${workspaceFolder}/euchre.exe`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Xcode</b>\n  </td>\n  <td markdown=\"1\">\n  Include [compile sources](https://eecs280staff.github.io/tutorials/setup_xcode.html#compile-sources): <br>\n  `euchre.cpp`, `Card.cpp`, `Pack.cpp`, `Player.cpp`\n  </td>\n</tr>\n<tr>\n  <td>\n  <b>Visual Studio</b>\n  </td>\n  <td markdown=\"1\">\n  [Exclude files](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#exclude-files-from-build) from the build: <br>\n  - Include `euchre.cpp`\n  - Exclude `Card_public_tests.cpp`, `Card_tests.cpp`, `Pack_public_tests.cpp`, `Pack_tests.cpp`, `Player_public_tests.cpp`, `Player_tests.cpp`, `main.cpp` (if present)\n  </td>\n</tr>\n</table>\n\nConfigure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)).  We recommend starting with the euchre test 00: `pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple`\n\nTo compile and run a Euchre game with four players.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n\n### Interface\n\nThe Euchre game driver takes several command line arguments, for example:\n\n```console\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n{: data-variant=\"no-line-numbers\" }\n\nHere's a short description of each command line argument.\n\n| `./euchre.exe` | Name of the executable |\n| `pack.in` | Filename of the pack |\n| `noshuffle` | Don't shuffle the deck, or use `shuffle` to turn on shuffling |\n| `1` | Points to win the game |\n| `Adi` | Name of player 0 |\n| `Simple` | Type of player 0 |\n| `Barbara` | Name of player 1 |\n| `Simple` | Type of player 1 |\n| `Chi-Chih` | Name of player 2 |\n| `Simple` | Type of player 2 |\n| `Dabbala` | Name of player 3 |\n| `Simple` | Type of player 3 |\n\nCheck for each of these errors:\n  - There are exactly 12 arguments, including the executable name.\n  - Points to win the game is between 1 and 100, inclusive.\n  - The shuffle argument is either `shuffle` or `noshuffle`.\n  - The types of each of the players are either `Simple` or `Human`.\n\nIf there is an error print this message and no other output.  Exit returning a non-zero value from `main`.\n\n```c++\ncout << \"Usage: euchre.exe PACK_FILENAME [shuffle|noshuffle] \"\n     << \"POINTS_TO_WIN NAME1 TYPE1 NAME2 TYPE2 NAME3 TYPE3 \"\n     << \"NAME4 TYPE4\" << endl;\n```\n\nYou must also verify the pack input file opens successfully. If it does not,\nprint this error message and exit returning a non-zero value from `main`.\n\n```c++\n// Assume pack_filename is a variable containing\n// the specified pack filename from argv\ncout << \"Error opening \" << pack_filename << endl;\n```\n{: data-variant=\"no-line-numbers\" }\n\nIf the file opens successfully, you may assume it is formatted correctly.\n\n### Design\n\nThe Euchre game driver coordinates all the [actions in the game](#playing-the-game).  *Take some time* to design this complex piece of code before beginning.\n\nWe recommend writing a `Game` ADT. It should have a constructor that takes in details like the players, points to win, etc. and a public `play()` function.  The `Game` and its helper functions do the hard work, and the `main()` function is simple.\n\n```c++\nclass Game {\n public:\n  // primer-spec-highlight-start\n  Game(/* game details */);\n  void play();\n  // primer-spec-highlight-end\n};\n\nint main(int argc, char **argv) {\n  // Read command line args and check for errors\n  // primer-spec-highlight-start\n  Game game(/* game details */);\n  game.play();\n  // primer-spec-highlight-end\n}\n```\n\nNext, consider which member data you'll need.  Examples include player pointers, pack of cards, etc.\n```c++\nclass Game {\n public:\n  Game(/* ... */);\n  void play();\n\n private:\n  // primer-spec-highlight-start\n  std::vector<Player*> players;\n  Pack pack;\n  // ...\n  // primer-spec-highlight-end\n};\n```\n\nWhich helper functions would help simplify the `play()` function?  Add these as private member functions.  Functions that shuffle, deal, make trump, and play a hand are a good starting point. \n```c++\nclass Game {\n public:\n  Game(/* ... */);\n  void play();\n\n private:\n  std::vector<Player*> players;\n  Pack pack;\n  // ...\n\n  // primer-spec-highlight-start\n  void shuffle();\n  void deal(/* ... */);\n  void make_trump(/* ... */);\n  void play_hand(/* ... */);\n  // ...\n  // primer-spec-highlight-end\n};\n```\n\n#### End of game\n{: .primer-spec-toc-ignore }\n\nAt the end of a game, delete the `Player` objects created by the [`Player_factory`](#player-factory).\n\n```c++\nfor (size_t i = 0; i < players.size(); ++i) {\n  delete players[i];\n}\n```\n\n### Example With Simple Players\n\nWe've provided full example output for a game with four simple players in `euchre_test00.out.correct`.  This section explains the output line by line.\n\nAs a reminder, all the output in this example is produced by the Euchre Game driver, not by the simple player code in `Player.cpp`.\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Debug differences in game output using `diff -y -B`, which shows differences side-by-side and ignores whitespace.  We'll use the `less` pager so we can scroll through the long terminal output.  Press `q` to quit.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple > euchre_test00.out\n$ diff -y -B euchre_test00.out.correct euchre_test00.out | less  # q to quit\n```\n</div>\n\nRun the example.\n\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple\n```\n\nFirst, print the executable and all arguments on the first line. Print\na single space at the end, which makes it easier to print an array.\n\n```\n./euchre.exe pack.in noshuffle 1 Adi Simple Barbara Simple Chi-Chih Simple Dabbala Simple \n```\n{: data-variant=\"legacy\" }\n\nAt the beginning of each hand, announce the hand, starting at zero,\nfollowed by the dealer and the upcard.\n\n```\nHand 0\nAdi deals\nJack of Diamonds turned up\n```\n{: data-variant=\"legacy\" }\n\nPrint the decision of each player during the making procedure. Print\nan extra newline when making, adding, and discarding is complete.\n\n```\nBarbara passes\nChi-Chih passes\nDabbala passes\nAdi passes\nBarbara orders up Hearts\n```\n{: data-variant=\"legacy\" }\n\nEach of the five tricks is announced, including the lead, cards played\nand the player that took the trick. Print an extra newline at the end\nof each trick.\n\n```\nJack of Spades led by Barbara\nKing of Spades played by Chi-Chih\nAce of Spades played by Dabbala\nNine of Diamonds played by Adi\nDabbala takes the trick\n\n```\n{: data-variant=\"legacy\" }\n\nAt the end of the hand, print the winners of the hand. When printing\nthe names of a partnership, print the player with the lower index\nfirst. For example, Adi was specified on the command line before\nChi-Chih, so he goes first.\n\n```\nAdi and Chi-Chih win the hand\n```\n{: data-variant=\"legacy\" }\n\nIf a march occurs, print `march!` followed by a newline. If euchre\noccurs, print `euchred!` followed by a newline. If neither occurs,\nprint nothing.\n\n```\neuchred!\n```\n{: data-variant=\"legacy\" }\n\nPrint the score, followed by an extra newline.\n\n```\nAdi and Chi-Chih have 2 points\nBarbara and Dabbala have 0 points\n```\n{: data-variant=\"legacy\" }\n\nWhen the game is over, print the winners of the game.\n\n```\nAdi and Chi-Chih win!\n```\n{: data-variant=\"legacy\" }\n\nThe output for a much longer game with four simple players is in `euchre_test01.out.correct`. See the [Euchre Test 01 Explanation](euchre_test01.html) for an explanation of the output.\n\n### Example With Human Players\n\nWeve provided full example output for a game with four human players in `euchre_test50.out.correct`. The input is in `euchre_test50.in`.  This section explains the output line by line.\n\nOutput that is specific to the Human Player should be printed by the Human Player code in (`Player.cpp`). All other output that is common to both Simple and Human Players should be printed by the Euchre Game driver.\n\nSet up input redirection ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#input-redirection), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#input-redirection), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#input-redirection), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#input-redirection)) to read `euchre_test50.in`. \n\nConfigure command line arguments ([VS Code (macOS)](https://eecs280staff.github.io/tutorials/setup_vscode_macos.html#arguments-and-options), [VS Code (Windows)](https://eecs280staff.github.io/tutorials/setup_vscode_wsl.html#arguments-and-options), [Xcode](https://eecs280staff.github.io/tutorials/setup_xcode.html#arguments-and-options), [Visual Studio](https://eecs280staff.github.io/tutorials/setup_visualstudio.html#arguments-and-options)) for euchre test 50: `noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human`\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Similar to the simple player, you can debug differences in game output using `diff -y -B`.  Press `q` to quit.\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human < euchre_test50.in > euchre_test50.out\n$ diff -y -B euchre_test50.out.correct euchre_test50.out | less  # q to quit\n```\n</div>\n\nRun the example, redirecting the input file `euchre_test50.in` to stdin.\n\n```console\n$ make euchre.exe\n$ ./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human < euchre_test50.in\n```\n\nFirst, print the executable and all arguments on the first line. Print\na single space at the end, which makes it easier to print an array.\n\n```\n./euchre.exe pack.in noshuffle 3 Ivan Human Judea Human Kunle Human Liskov Human \n```\n{: data-variant=\"legacy\" }\n\nAt the beginning of each hand, announce the hand, starting at zero,\nfollowed by the dealer and the upcard.\n\n```\nHand 0\nIvan deals\nJack of Diamonds turned up\n```\n{: data-variant=\"legacy\" }\n\nPrint the hand of each player during the making procedure, followed by\na prompt for their making decision. End the prompt with a newline\nimmediately after the colon.\n\n```\nHuman player Judea's hand: [0] Nine of Spades\nHuman player Judea's hand: [1] Ten of Spades\nHuman player Judea's hand: [2] Jack of Spades\nHuman player Judea's hand: [3] King of Hearts\nHuman player Judea's hand: [4] Ace of Hearts\nHuman player Judea, please enter a suit, or \"pass\":\n```\n{: data-variant=\"legacy\" }\n\nPrint the decision of each player during the making procedure.\n\n```\nJudea passes\n...\nJudea orders up Hearts\n```\n{: data-variant=\"legacy\" }\n\nPrint the dealer's hand if a player orders up during the first round,\nas well as an option to discard the upcard. Prompt the dealer to\nselect a card to discard, ending the prompt with a newline immediately\nafter the colon. Print an extra newline when making, adding, and\ndiscarding is done.\n\n```\nHuman player Ivan's hand: [0] Nine of Diamonds\n...\nHuman player Ivan's hand: [4] Ace of Clubs\nDiscard upcard: [-1]\nHuman player Ivan, please select a card to discard:\n```\n{: data-variant=\"legacy\" }\n\nFor each trick, print the Human Player's hand and prompt them to\nselect a card.\n\n```\nHuman player Judea's hand: [0] Nine of Spades\n...\nHuman player Judea's hand: [4] Ace of Hearts\nHuman player Judea, please select a card:\n```\n{: data-variant=\"legacy\" }\n\nThen print the card played or lead.\n\n```\nNine of Spades led by Judea\n```\n{: data-variant=\"legacy\" }\n\nAt the end of each trick, print the player who took the trick as well\nas an extra newline.\n\n```\nLiskov takes the trick\n```\n{: data-variant=\"legacy\" }\n\nAt the end of the hand, print the winners of the hand. When printing\nthe names of a partnership, print the player with the lower index\nfirst. For example, Ivan was specified on the command line before\nKunle, so he goes first.\n\n```\nIvan and Kunle win the hand\n```\n{: data-variant=\"legacy\" }\n\nIf a march occurs, print `march!` followed by a newline. If euchre\noccurs, print `euchred!` followed by a newline. If neither occurs, print\nnothing.\n\n```\neuchred!\n```\n{: data-variant=\"legacy\" }\n\nPrint the score, followed by an extra newline.\n\n```\nIvan and Kunle have 2 points\nJudea and Liskov have 0 points\n```\n{: data-variant=\"legacy\" }\n\nWhen the game is over, print the winners of the game.\n\n```\nIvan and Kunle win!\n```\n{: data-variant=\"legacy\" }\n\n\n## Submission and Grading\n\nSubmit these files to the [autograder](https://autograder.io).\n  - `Card.cpp`\n  - `Card_tests.cpp`\n  - `Pack.cpp`\n  - `Player.cpp`\n  - `Player_tests.cpp`\n  - `euchre.cpp`\n\nYou do not have to submit `Pack_tests.cpp` to the autograder.\n\nThis project will be autograded for correctness, comprehensiveness of\nyour test cases, and programming style. See the [style checking\ntutorial](https://eecs280staff.github.io/tutorials/setup_style.html)\nfor the criteria and how to check your style automatically on CAEN.\n\n### Checkpoint\n\nThis project is graded on an early checkpoint as well as the full submission. The checkpoint submission is worth 0.5% of your overall course grade. The full submission is worth 9.5% of your overall course grade.\n\nThe checkpoint consists of everything except the [Euchre Game](#euchre-game) driver.\n\nSubmit these files to the [autograder](https://autograder.io).\n  - `Card.cpp`\n  - `Card_tests.cpp`\n  - `Pack.cpp`\n  - `Player.cpp`\n  - `Player_tests.cpp`\n\nThere are no private tests and no style grading at the checkpoint.\n\nYour checkpoint score does not change after the checkpoint deadline, even though we run the same public tests and [mutation tests](#unit-test-grading) at both the checkpoint and full submission.\n\nAfter the checkpoint autograder closes, the full submission autograder will open.\n\n### Testing\n\nRun all the unit tests and system tests.  This includes the public tests we provided and the unit tests that you wrote.\n\n```console\n$ make test\n```\n\n<div class=\"primer-spec-callout info\" markdown=\"1\">\n**Pro-tip:** Run commands in parallel with `make -j`.\n```console\n$ make -j4 test\n```\n{: data-variant=\"no-line-numbers\" }\n</div>\n\n### Unit Test Grading\n\nWe will autograde your `Card_tests.cpp` and `Player_tests.cpp` unit tests. Note that your player tests should only test the \"simple player\", not the \"human player\".\n\nYour unit tests must use the [unit test framework](https://eecs280staff.github.io/unit_test_framework/).\n\nA test suite must run in less than 5 seconds and contain 50 or fewer `TEST()` functions.  One test suite is one `_tests.cpp` file.\n\nTo grade your unit tests, we use a set of intentionally buggy instructor solutions.  You get points for catching the bugs.\n\n1.  We compile and run your unit tests with a **correct solution**.\n    - Tests that pass are **valid**.\n    - Tests that fail are **invalid**, they falsely report a bug.\n3.  We compile and run all of your **valid** tests against each **buggy solution**.\n    - If any of your tests fail, you caught the bug.\n    - You earn points for each bug that you catch.\n\n### Requirements and Restrictions\n\nIt is our goal for you to gain practice with good C++ code, classes,\nand polymorphism.\n\n\n| DO | DO NOT |\n| -- | ------ |\n| Modify `.cpp` files | Modify `.hpp` files |\n| Write helper functions in `Card.cpp` and `Pack.cpp` as non-member functions in the `.cpp` files and declare them `static` | Modify `.hpp` files |\n| Use these libraries: `<iostream>`, `<fstream>`, `<cstdlib>`, `<cassert>`, `<cstring>`, `<string>`, `<array>`, `<vector>`, `<sstream>` <br>Use the `<algorithm>` library, but only for the `sort()` function. | Use other libraries. <br><br>Use `<algorithm>` library for anything other than the `sort()` function. |\n| `#include` a library to use its functions | Assume that the compiler will find the library for you (some do, some don't) |\n| | `#include` an unnecessary `.hpp` file, such as `#include Pack.hpp` in either `Card.cpp` or in `Player.cpp` (This introduces undesirable dependencies, e.g. that the `Card`/`Player` ADTs require the `Pack` ADT to exist and be properly implemented.) |\n| Use C++ strings | Use C-strings other than when checking `argv` |\n| Send all output to standard out (AKA stdout) by using `cout` | Send any output to standard error (AKA stderr) by using `cerr` |\n| `const` global variables | Global or static variables |\n| Pass large structs or classes by reference | Pass large structs or classes by value |\n| Pass by `const` reference when appropriate | \"I don't think I'll modify it ...\" |\n| Variables on the stack | Dynamic memory (`new`, `malloc()`, etc.) outside of the `Player_factory`. |\n\n\n## Acknowledgments\n\nThe original project was written by Andrew DeOrio, Fall 2013. The\nproject was modified to use C++ style object oriented programming and\nthe specification updated by the Fall 2015 staff.\n\nThe code files:\nCard.cpp:\n#include <cassert>\n#include <iostream>\n#include <array>\n#include \"Card.hpp\"\n\nusing namespace std;\n\n/////////////// Rank operator implementations - DO NOT CHANGE ///////////////\n\nconstexpr const char *const RANK_NAMES[] = {\n  \"Two\",   // TWO\n  \"Three\", // THREE\n  \"Four\",  // FOUR\n  \"Five\",  // FIVE\n  \"Six\",   // SIX\n  \"Seven\", // SEVEN\n  \"Eight\", // EIGHT\n  \"Nine\",  // NINE\n  \"Ten\",   // TEN\n  \"Jack\",  // JACK\n  \"Queen\", // QUEEN\n  \"King\",  // KING\n  \"Ace\"    // ACE\n};\n\n//REQUIRES str represents a valid rank (\"Two\", \"Three\", ..., \"Ace\")\n//EFFECTS returns the Rank corresponding to str, for example \"Two\" -> TWO\nRank string_to_rank(const std::string &str) {\n  for(int r = TWO; r <= ACE; ++r) {\n    if (str == RANK_NAMES[r]) {\n      return static_cast<Rank>(r);\n    }\n  }\n  assert(false); // Input string didn't match any rank\n  return {};\n}\n\n//EFFECTS Prints Rank to stream, for example \"Two\"\nstd::ostream & operator<<(std::ostream &os, Rank rank) {\n  os << RANK_NAMES[rank];\n  return os;\n}\n\n//REQUIRES If any input is read, it must be a valid rank\n//EFFECTS Reads a Rank from a stream, for example \"Two\" -> TWO\nstd::istream & operator>>(std::istream &is, Rank &rank) {\n  string str;\n  if(is >> str) {\n    rank = string_to_rank(str);\n  }\n  return is;\n}\n\n\n\n/////////////// Suit operator implementations - DO NOT CHANGE ///////////////\n\nconstexpr const char *const SUIT_NAMES[] = {\n  \"Spades\",   // SPADES\n  \"Hearts\",   // HEARTS\n  \"Clubs\",    // CLUBS\n  \"Diamonds\", // DIAMONDS\n};\n\n//REQUIRES str represents a valid suit (\"Spades\", \"Hearts\", \"Clubs\", or \"Diamonds\")\n//EFFECTS returns the Suit corresponding to str, for example \"Clubs\" -> CLUBS\nSuit string_to_suit(const std::string &str) {\n  for(int s = SPADES; s <= DIAMONDS; ++s) {\n    if (str == SUIT_NAMES[s]) {\n      return static_cast<Suit>(s);\n    }\n  }\n  assert(false); // Input string didn't match any suit\n  return {};\n}\n\n//EFFECTS Prints Suit to stream, for example \"Spades\"\nstd::ostream & operator<<(std::ostream &os, Suit suit) {\n  os << SUIT_NAMES[suit];\n  return os;\n}\n\n//REQUIRES If any input is read, it must be a valid suit\n//EFFECTS Reads a Suit from a stream, for example \"Spades\" -> SPADES\nstd::istream & operator>>(std::istream &is, Suit &suit) {\n  string str;\n  if (is >> str) {\n    suit = string_to_suit(str);\n  }\n  return is;\n}\n\n\n/////////////// Write your implementation for Card below ///////////////\n\n\n// NOTE: We HIGHLY recommend you check out the operator overloading\n// tutorial in the project spec before implementing\n// the following operator overload functions:\n//   operator<<\n//   operator>>\n//   operator<\n//   operator<=\n//   operator>\n//   operator>=\n//   operator==\n//   operator!=\n\nCard.hpp:\n#ifndef CARD_HPP\n#define CARD_HPP\n/* Card.hpp\n *\n * Represents a single playing card\n *\n * by Andrew DeOrio\n * awdeorio@umich.edu\n * 2014-12-21\n */\n\n#include <iostream>\n\n// Represent a Card's Rank.\n// Rank is a type that can represent the specific values\n// listed in the definition below, but no others. (In memory\n// the Rank values are represented as integers from 0 to 12.)\n// Use the values as constants, for example:\n//   Rank r1 = FOUR;\n//   Rank r2 = NINE;\n// Ranks may be compared (this compares the underlying int values):\n//   if (r1 < r2) { // this condition is true\n// Overloaded << and >> operators are also defined farther below to\n// enable stream input/output for Rank objects:\n//   cout << r1 << endl; // prints \"Four\"\n//   cin >> r2 << endl;  // reads a string from cin and updates r2\n// Because the underlying representation of the enum is an integer,\n// objects of type Rank are ok to pass/return by value.\nenum Rank {\n  TWO     = 0,\n  THREE   = 1,\n  FOUR    = 2,\n  FIVE    = 3,\n  SIX     = 4,\n  SEVEN   = 5,\n  EIGHT   = 6,\n  NINE    = 7,\n  TEN     = 8,\n  JACK    = 9,\n  QUEEN   = 10,\n  KING    = 11,\n  ACE     = 12,\n};\n\n//REQUIRES str represents a valid rank (\"Two\", \"Three\", ..., \"Ace\")\n//EFFECTS returns the Rank corresponding to str, for example \"Two\" -> TWO\nRank string_to_rank(const std::string &str);\n\n//EFFECTS Prints Rank to stream, for example \"Two\"\nstd::ostream & operator<<(std::ostream &os, Rank rank);\n\n//REQUIRES If any input is read, it must be a valid rank\n//EFFECTS Reads a Rank from a stream, for example \"Two\" -> TWO\nstd::istream & operator>>(std::istream &is, Rank &rank);\n\n// Represent a Card's suit\nenum Suit {\n  SPADES   = 0,\n  HEARTS   = 1,\n  CLUBS    = 2,\n  DIAMONDS = 3,\n};\n\n//REQUIRES str represents a valid suit (\"Spades\", \"Hearts\", \"Clubs\", or \"Diamonds\")\n//EFFECTS returns the Suit corresponding to str, for example \"Clubs\" -> CLUBS\nSuit string_to_suit(const std::string &str);\n\n//EFFECTS Prints Suit to stream, for example \"Spades\"\nstd::ostream & operator<<(std::ostream &os, Suit suit);\n\n//REQUIRES If any input is read, it must be a valid suit\n//EFFECTS Reads a Suit from a stream, for example \"Spades\" -> SPADES\nstd::istream & operator>>(std::istream &is, Suit &suit);\n\n\nclass Card {\npublic:\n\n  //EFFECTS Initializes Card to the Two of Spades\n  Card();\n\n  //EFFECTS Initializes Card to specified rank and suit\n  Card(Rank rank_in, Suit suit_in);\n\n  //EFFECTS Returns the rank\n  Rank get_rank() const;\n\n  //EFFECTS Returns the suit.  Does not consider trump.\n  Suit get_suit() const;\n\n  //EFFECTS Returns the suit\n  //HINT: the left bower is the trump suit!\n  Suit get_suit(Suit trump) const;\n\n  //EFFECTS Returns true if card is a face card (Jack, Queen, King or Ace)\n  bool is_face_or_ace() const;\n\n  //EFFECTS Returns true if card is the Jack of the trump suit\n  bool is_right_bower(Suit trump) const;\n\n  //EFFECTS Returns true if card is the Jack of the next suit\n  bool is_left_bower(Suit trump) const;\n\n  //EFFECTS Returns true if the card is a trump card.  All cards of the trump\n  // suit are trump cards.  The left bower is also a trump card.\n  bool is_trump(Suit trump) const;\n\nprivate:\n  Rank rank;\n  Suit suit;\n\n  // This \"friend declaration\" allows the implementation of operator>>\n  // to access private member variables of the Card class.\n  friend std::istream & operator>>(std::istream &is, Card &card);\n};\n\n//EFFECTS Prints Card to stream, for example \"Two of Spades\"\nstd::ostream & operator<<(std::ostream &os, const Card &card);\n\n//EFFECTS Reads a Card from a stream in the format \"Two of Spades\"\n//NOTE The Card class declares this operator>> \"friend\" function,\n//     which means it is allowed to access card.rank and card.suit.\nstd::istream & operator>>(std::istream &is, Card &card);\n\n//EFFECTS Returns true if lhs is lower value than rhs.\n//  Does not consider trump.\nbool operator<(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is lower value than rhs or the same card as rhs.\n//  Does not consider trump.\nbool operator<=(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is higher value than rhs.\n//  Does not consider trump.\nbool operator>(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is higher value than rhs or the same card as rhs.\n//  Does not consider trump.\nbool operator>=(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is same card as rhs.\n//  Does not consider trump.\nbool operator==(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is not the same card as rhs.\n//  Does not consider trump.\nbool operator!=(const Card &lhs, const Card &rhs);\n\n//EFFECTS returns the next suit, which is the suit of the same color\nSuit Suit_next(Suit suit);\n\n//EFFECTS Returns true if a is lower value than b.  Uses trump to determine\n// order, as described in the spec.\nbool Card_less(const Card &a, const Card &b, Suit trump);\n\n//EFFECTS Returns true if a is lower value than b.  Uses both the trump suit\n//  and the suit led to determine order, as described in the spec.\nbool Card_less(const Card &a, const Card &b, const Card &led_card, Suit trump);\n\n#endif // CARD_HPP\n\n\nPack.hpp:\n#ifndef PACK_HPP\n#define PACK_HPP\n/* Pack.hpp\n *\n * Represents a pack of playing cards\n *\n * by Andrew DeOrio <awdeorio@umich.edu>\n * 2014-12-21\n */\n\n\n#include \"Card.hpp\"\n#include <array>\n#include <string>\n\nclass Pack {\npublic:\n  // EFFECTS: Initializes the Pack to be in the following standard order:\n  //          the cards of the lowest suit arranged from lowest rank to\n  //          highest rank, followed by the cards of the next lowest suit\n  //          in order from lowest to highest rank, and so on. \n  // NOTE: The standard order is the same as that in pack.in.\n  // NOTE: Do NOT use pack.in in your implementation of this function\n  // NOTE: The pack is initially full, with no cards dealt.\n  Pack();\n\n  // REQUIRES: pack_input contains a representation of a Pack in the\n  //           format required by the project specification\n  // MODIFIES: pack_input\n  // EFFECTS: Initializes Pack by reading from pack_input.\n  // NOTE: The pack is initially full, with no cards dealt.\n  Pack(std::istream& pack_input);\n\n  // REQUIRES: cards remain in the Pack\n  // EFFECTS: Returns the next card in the pack and increments the next index\n  Card deal_one();\n\n  // EFFECTS: Resets next index to first card in the Pack\n  void reset();\n\n  // EFFECTS: Shuffles the Pack and resets the next index. This\n  //          performs an in shuffle seven times. See\n  //          https://en.wikipedia.org/wiki/In_shuffle.\n  void shuffle();\n\n  // EFFECTS: returns true if there are no more cards left in the pack\n  bool empty() const;\n\nprivate:\n  static const int PACK_SIZE = 24;\n  std::array<Card, PACK_SIZE> cards;\n  int next; //index of next card to be dealt\n};\n\n#endif // PACK_HPP\n\n\nPlayer.cpp\n#include \"Player.hpp\"\n\nclass SimplePlayer : public Player {\n    public:\n     //EFFECTS: Creates a SimplePlayer with the given name\n     SimplePlayer(const std::string &name);\n   \n     //EFFECTS: Returns player's name\n     const std::string & get_name() const;\n   \n     //REQUIRES player has less than MAX_HAND_SIZE cards\n     //EFFECTS  adds Card c to Player's hand\n     void add_card(const Card &c);\n   \n     //REQUIRES round is 1 or 2\n     //EFFECTS If Player wishes to order up a trump suit then return true and\n     //  change order_up_suit to desired suit.  If Player wishes to pass, then do\n     //  not modify order_up_suit and return false.\n     // In making trump, a Simple Player considers the upcard, which player dealt, and whether it is the first or second round of making trump. A more comprehensive strategy would consider the other players responses, but we will keep it simple.\n     // During round one, a Simple Player considers ordering up the suit of the upcard, which would make that suit trump. They will order up if that would mean they have two or more cards that are either face or ace cards of the trump suit (the right and left bowers, and Q, K, A of the trump suit, which is the suit proposed by the upcard). (A Simple Player does not consider whether they are the dealer and could gain an additional trump by picking up the upcard.)\n     // During round two, a Simple Player considers ordering up the suit with the same color as the upcard, which would make that suit trump. They will order up if that would mean they have one or more cards that are either face or ace cards of the trump suit in their hand (the right and left bowers, and Q, K, A of the order-up suit). For example, if the upcard is a Heart and the player has the King of Diamonds in their hand, they will order up Diamonds. The Simple Player will not order up any other suit. If making reaches the dealer during the second round, we invoke screw the dealer, where the dealer is forced to order up. In the case of screw the dealer, the dealer will always order up the suit with the same color as the upcard.\n     bool make_trump(const Card &upcard, bool is_dealer,\n                     int round, Suit &order_up_suit) const;\n   \n     //REQUIRES Player has at least one card\n     //EFFECTS  If the trump suit is ordered up during round one, the dealer picks up the upcard. The dealer then discards the lowest card in their hand, even if this is the upcard, for a final total of five cards. (Note that at this point, the trump suit is the suit of the upcard.)\n     void add_and_discard(const Card &upcard);\n   \n     //REQUIRES Player has at least one card\n     //EFFECTS  Leads one Card from Player's hand according to their strategy\n     //  \"Lead\" means to play the first Card in a trick.  The card\n     //  is removed the player's hand.\n     //  When a Simple Player leads a trick, they play the highest non-trump card in their hand. If they have only trump cards, they play the highest trump card in their hand.\n     Card lead_card(Suit trump);\n   \n     //REQUIRES Player has at least one card\n     //EFFECTS  Plays one Card from Player's hand according to their strategy.\n     //  The card is removed from the player's hand.\n     //  When playing a card, Simple Players use a simple strategy that considers only the suit that was led. A more complex strategy would also consider the cards on the table.\n     //  If a Simple Player can follow suit, they play the highest card that follows suit. Otherwise, they play the lowest card in their hand.\n     Card play_card(const Card &led_card, Suit trump);\n   \n    private:\n     std::string name;\n     std::vector<Card> hand;\n   };\n\n// The Human Player reads input from the human user. You may assume all user input is correctly formatted and has correct values. You may also assume the user will follow the rules of the game and not try to cheat.\nclass HumanPlayer: public Player {\n    public:\n    //EFFECTS: Creates a SimplePlayer with the given name\n    HumanPlayer(const std::string &name);\n  \n    //EFFECTS: Returns player's name\n    const std::string & get_name() const;\n  \n    //REQUIRES player has less than MAX_HAND_SIZE cards\n    //EFFECTS  adds Card c to Player's hand\n    void add_card(const Card &c);\n  \n    //REQUIRES round is 1 or 2\n    //EFFECTS  If Player wishes to order up a trump suit then return true and\n  //  change order_up_suit to desired suit.  If Player wishes to pass, then do\n  //  not modify order_up_suit and return false.\n  //  When making trump reaches a Human Player, first print the Players hand. Then, prompt the user for their decision to pass or order up. The user will then enter one of the following: Spades, Hearts, Clubs, Diamonds, or pass to either order up the specified suit or pass. This procedure is the same for both rounds of making trump.\n    bool make_trump(const Card &upcard, bool is_dealer,\n                    int round, Suit &order_up_suit) const;\n  \n    //REQUIRES Player has at least one card\n    //EFFECTS  Player adds one card to hand and removes one card from hand.\n    //  If a Human Player is the dealer and someone orders up during the first round of making, the Human Player will pick up the upcard and discard a card of their choice. Print the Players hand and an option to discard the upcard. Then, prompt the user to select a card to discard. The user will then enter the number corresponding to the card they want to discard (or -1 if they want to discard the upcard).\n    void add_and_discard(const Card &upcard);\n  \n    //REQUIRES Player has at least one card\n    //EFFECTS  Leads one Card from Player's hand according to their strategy\n    //  \"Lead\" means to play the first Card in a trick.  The card\n    //  is removed the player's hand.\n    //  When it is the Human Players turn to lead or play a trick, first print the Players hand. Then, prompt the user to select a card. The user will then enter the number corresponding to the card they want to play.\n    Card lead_card(Suit trump);\n  \n    //REQUIRES Player has at least one card\n    //EFFECTS  Plays one Card from Player's hand according to their strategy.\n    //  The card is removed from the player's hand.\n    //   When it is the Human Players turn to lead or play a trick, first print the Players hand. Then, prompt the user to select a card. The user will then enter the number corresponding to the card they want to play.\n    Card play_card(const Card &led_card, Suit trump);\n  \n   private:\n    std::string name;\n    std::vector<Card> hand;\n   };\n\n\n   Player.hpp\n   #ifndef PLAYER_HPP\n#define PLAYER_HPP\n/* Player.hpp\n *\n * Euchre player interface\n *\n * by Andrew DeOrio\n * awdeorio@umich.edu\n * 2014-12-21\n */\n\n\n#include \"Card.hpp\"\n#include <string>\n#include <vector>\n\nclass Player {\n public:\n  //EFFECTS returns player's name\n  virtual const std::string & get_name() const = 0;\n\n  //REQUIRES player has less than MAX_HAND_SIZE cards\n  //EFFECTS  adds Card c to Player's hand\n  virtual void add_card(const Card &c) = 0;\n\n  //REQUIRES round is 1 or 2\n  //MODIFIES order_up_suit\n  //EFFECTS If Player wishes to order up a trump suit then return true and\n  //  change order_up_suit to desired suit.  If Player wishes to pass, then do\n  //  not modify order_up_suit and return false.\n  virtual bool make_trump(const Card &upcard, bool is_dealer,\n                          int round, Suit &order_up_suit) const = 0;\n\n  //REQUIRES Player has at least one card\n  //EFFECTS  Player adds one card to hand and removes one card from hand.\n  virtual void add_and_discard(const Card &upcard) = 0;\n\n  //REQUIRES Player has at least one card\n  //EFFECTS  Leads one Card from Player's hand according to their strategy\n  //  \"Lead\" means to play the first Card in a trick.  The card\n  //  is removed the player's hand.\n  virtual Card lead_card(Suit trump) = 0;\n\n  //REQUIRES Player has at least one card\n  //EFFECTS  Plays one Card from Player's hand according to their strategy.\n  //  The card is removed from the player's hand.\n  virtual Card play_card(const Card &led_card, Suit trump) = 0;\n\n  // Maximum number of cards in a player's hand\n  static const int MAX_HAND_SIZE = 5;\n\n  // Needed to avoid some compiler errors\n  // NOTE: Do NOT write a destructor in the Player subclasses. The compiler-generated ones will work fine.\n  virtual ~Player() {}\n};\n\n//EFFECTS: Returns a pointer to a player with the given name and strategy\n//To create an object that won't go out of scope when the function returns,\n//use \"return new Simple(name)\" or \"return new Human(name)\"\n//Don't forget to call \"delete\" on each Player* after the game is over\nPlayer * Player_factory(const std::string &name, const std::string &strategy);\n\n//EFFECTS: Prints player's name to os\nstd::ostream & operator<<(std::ostream &os, const Player &p);\n#endif // PLAYER_HPP\n\n\neuchre.cpp:\n#include <iostream>\n#include <fstream>\n#include <string>\n#include \"Card.hpp\"\n#include \"Pack.hpp\"\n#include \"Player.hpp\"\n#include <cstring>\n\nclass Game {\n    public:\n     Game(/* ... */);\n     void play();\n   \n    private:\n     std::vector<Player*> players;\n     Pack pack;\n     // ...\n   \n     void shuffle();\n     void deal(/* ... */);\n     void make_trump(/* ... */);\n     void play_hand(/* ... */);\n     // ...\n   };"
  },
  "doc-ed07c3d440d65571993de7229d900996": {
    "content": "#include <iostream>\n#include <fstream>\n#include <string>\n#include \"Card.hpp\"\n#include \"Pack.hpp\"\n#include \"Player.hpp\"\n#include <cstring>\n\nclass Game {\n    public:\n     Game(/* ... */);\n     void play();\n   \n    private:\n     std::vector<Player*> players;\n     Pack pack;\n     // ...\n   \n     void shuffle();\n     void deal(/* ... */);\n     void make_trump(/* ... */);\n     void play_hand(/* ... */);\n     // ...\n   };"
  },
  "doc-e141958ad1497299b0aa0a049e4c90ea": {
    "content": "#include <cassert>\n#include <iostream>\n#include <array>\n#include \"Card.hpp\"\n\nusing namespace std;\n\n/////////////// Rank operator implementations - DO NOT CHANGE ///////////////\n\nconstexpr const char *const RANK_NAMES[] = {\n  \"Two\",   // TWO\n  \"Three\", // THREE\n  \"Four\",  // FOUR\n  \"Five\",  // FIVE\n  \"Six\",   // SIX\n  \"Seven\", // SEVEN\n  \"Eight\", // EIGHT\n  \"Nine\",  // NINE\n  \"Ten\",   // TEN\n  \"Jack\",  // JACK\n  \"Queen\", // QUEEN\n  \"King\",  // KING\n  \"Ace\"    // ACE\n};\n\n//REQUIRES str represents a valid rank (\"Two\", \"Three\", ..., \"Ace\")\n//EFFECTS returns the Rank corresponding to str, for example \"Two\" -> TWO\nRank string_to_rank(const std::string &str) {\n  for(int r = TWO; r <= ACE; ++r) {\n    if (str == RANK_NAMES[r]) {\n      return static_cast<Rank>(r);\n    }\n  }\n  assert(false); // Input string didn't match any rank\n  return {};\n}\n\n//EFFECTS Prints Rank to stream, for example \"Two\"\nstd::ostream & operator<<(std::ostream &os, Rank rank) {\n  os << RANK_NAMES[rank];\n  return os;\n}\n\n//REQUIRES If any input is read, it must be a valid rank\n//EFFECTS Reads a Rank from a stream, for example \"Two\" -> TWO\nstd::istream & operator>>(std::istream &is, Rank &rank) {\n  string str;\n  if(is >> str) {\n    rank = string_to_rank(str);\n  }\n  return is;\n}\n\n\n\n/////////////// Suit operator implementations - DO NOT CHANGE ///////////////\n\nconstexpr const char *const SUIT_NAMES[] = {\n  \"Spades\",   // SPADES\n  \"Hearts\",   // HEARTS\n  \"Clubs\",    // CLUBS\n  \"Diamonds\", // DIAMONDS\n};\n\n//REQUIRES str represents a valid suit (\"Spades\", \"Hearts\", \"Clubs\", or \"Diamonds\")\n//EFFECTS returns the Suit corresponding to str, for example \"Clubs\" -> CLUBS\nSuit string_to_suit(const std::string &str) {\n  for(int s = SPADES; s <= DIAMONDS; ++s) {\n    if (str == SUIT_NAMES[s]) {\n      return static_cast<Suit>(s);\n    }\n  }\n  assert(false); // Input string didn't match any suit\n  return {};\n}\n\n//EFFECTS Prints Suit to stream, for example \"Spades\"\nstd::ostream & operator<<(std::ostream &os, Suit suit) {\n  os << SUIT_NAMES[suit];\n  return os;\n}\n\n//REQUIRES If any input is read, it must be a valid suit\n//EFFECTS Reads a Suit from a stream, for example \"Spades\" -> SPADES\nstd::istream & operator>>(std::istream &is, Suit &suit) {\n  string str;\n  if (is >> str) {\n    suit = string_to_suit(str);\n  }\n  return is;\n}\n\n\n/////////////// Write your implementation for Card below ///////////////\n\n\n// NOTE: We HIGHLY recommend you check out the operator overloading\n// tutorial in the project spec before implementing\n// the following operator overload functions:\n//   operator<<\n//   operator>>\n//   operator<\n//   operator<=\n//   operator>\n//   operator>=\n//   operator==\n//   operator!="
  },
  "doc-33f3399fb13c8c8a50b7ada1195ab853": {
    "content": "#ifndef CARD_HPP\n#define CARD_HPP\n/* Card.hpp\n *\n * Represents a single playing card\n *\n * by Andrew DeOrio\n * awdeorio@umich.edu\n * 2014-12-21\n */\n\n#include <iostream>\n\n// Represent a Card's Rank.\n// Rank is a type that can represent the specific values\n// listed in the definition below, but no others. (In memory\n// the Rank values are represented as integers from 0 to 12.)\n// Use the values as constants, for example:\n//   Rank r1 = FOUR;\n//   Rank r2 = NINE;\n// Ranks may be compared (this compares the underlying int values):\n//   if (r1 < r2) { // this condition is true\n// Overloaded << and >> operators are also defined farther below to\n// enable stream input/output for Rank objects:\n//   cout << r1 << endl; // prints \"Four\"\n//   cin >> r2 << endl;  // reads a string from cin and updates r2\n// Because the underlying representation of the enum is an integer,\n// objects of type Rank are ok to pass/return by value.\nenum Rank {\n  TWO     = 0,\n  THREE   = 1,\n  FOUR    = 2,\n  FIVE    = 3,\n  SIX     = 4,\n  SEVEN   = 5,\n  EIGHT   = 6,\n  NINE    = 7,\n  TEN     = 8,\n  JACK    = 9,\n  QUEEN   = 10,\n  KING    = 11,\n  ACE     = 12,\n};\n\n//REQUIRES str represents a valid rank (\"Two\", \"Three\", ..., \"Ace\")\n//EFFECTS returns the Rank corresponding to str, for example \"Two\" -> TWO\nRank string_to_rank(const std::string &str);\n\n//EFFECTS Prints Rank to stream, for example \"Two\"\nstd::ostream & operator<<(std::ostream &os, Rank rank);\n\n//REQUIRES If any input is read, it must be a valid rank\n//EFFECTS Reads a Rank from a stream, for example \"Two\" -> TWO\nstd::istream & operator>>(std::istream &is, Rank &rank);\n\n// Represent a Card's suit\nenum Suit {\n  SPADES   = 0,\n  HEARTS   = 1,\n  CLUBS    = 2,\n  DIAMONDS = 3,\n};\n\n//REQUIRES str represents a valid suit (\"Spades\", \"Hearts\", \"Clubs\", or \"Diamonds\")\n//EFFECTS returns the Suit corresponding to str, for example \"Clubs\" -> CLUBS\nSuit string_to_suit(const std::string &str);\n\n//EFFECTS Prints Suit to stream, for example \"Spades\"\nstd::ostream & operator<<(std::ostream &os, Suit suit);\n\n//REQUIRES If any input is read, it must be a valid suit\n//EFFECTS Reads a Suit from a stream, for example \"Spades\" -> SPADES\nstd::istream & operator>>(std::istream &is, Suit &suit);\n\n\nclass Card {\npublic:\n\n  //EFFECTS Initializes Card to the Two of Spades\n  Card();\n\n  //EFFECTS Initializes Card to specified rank and suit\n  Card(Rank rank_in, Suit suit_in);\n\n  //EFFECTS Returns the rank\n  Rank get_rank() const;\n\n  //EFFECTS Returns the suit.  Does not consider trump.\n  Suit get_suit() const;\n\n  //EFFECTS Returns the suit\n  //HINT: the left bower is the trump suit!\n  Suit get_suit(Suit trump) const;\n\n  //EFFECTS Returns true if card is a face card (Jack, Queen, King or Ace)\n  bool is_face_or_ace() const;\n\n  //EFFECTS Returns true if card is the Jack of the trump suit\n  bool is_right_bower(Suit trump) const;\n\n  //EFFECTS Returns true if card is the Jack of the next suit\n  bool is_left_bower(Suit trump) const;\n\n  //EFFECTS Returns true if the card is a trump card.  All cards of the trump\n  // suit are trump cards.  The left bower is also a trump card.\n  bool is_trump(Suit trump) const;\n\nprivate:\n  Rank rank;\n  Suit suit;\n\n  // This \"friend declaration\" allows the implementation of operator>>\n  // to access private member variables of the Card class.\n  friend std::istream & operator>>(std::istream &is, Card &card);\n};\n\n//EFFECTS Prints Card to stream, for example \"Two of Spades\"\nstd::ostream & operator<<(std::ostream &os, const Card &card);\n\n//EFFECTS Reads a Card from a stream in the format \"Two of Spades\"\n//NOTE The Card class declares this operator>> \"friend\" function,\n//     which means it is allowed to access card.rank and card.suit.\nstd::istream & operator>>(std::istream &is, Card &card);\n\n//EFFECTS Returns true if lhs is lower value than rhs.\n//  Does not consider trump.\nbool operator<(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is lower value than rhs or the same card as rhs.\n//  Does not consider trump.\nbool operator<=(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is higher value than rhs.\n//  Does not consider trump.\nbool operator>(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is higher value than rhs or the same card as rhs.\n//  Does not consider trump.\nbool operator>=(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is same card as rhs.\n//  Does not consider trump.\nbool operator==(const Card &lhs, const Card &rhs);\n\n//EFFECTS Returns true if lhs is not the same card as rhs.\n//  Does not consider trump.\nbool operator!=(const Card &lhs, const Card &rhs);\n\n//EFFECTS returns the next suit, which is the suit of the same color\nSuit Suit_next(Suit suit);\n\n//EFFECTS Returns true if a is lower value than b.  Uses trump to determine\n// order, as described in the spec.\nbool Card_less(const Card &a, const Card &b, Suit trump);\n\n//EFFECTS Returns true if a is lower value than b.  Uses both the trump suit\n//  and the suit led to determine order, as described in the spec.\nbool Card_less(const Card &a, const Card &b, const Card &led_card, Suit trump);\n\n#endif // CARD_HPP"
  },
  "doc-35fcbbdcf530cd25b359f0c2d286bf01": {
    "content": "#include \"Player.hpp\"\n\nclass SimplePlayer : public Player {\n    public:\n     //EFFECTS: Creates a SimplePlayer with the given name\n     SimplePlayer(const std::string &name);\n   \n     //EFFECTS: Returns player's name\n     const std::string & get_name() const;\n   \n     //REQUIRES player has less than MAX_HAND_SIZE cards\n     //EFFECTS  adds Card c to Player's hand\n     void add_card(const Card &c);\n   \n     //REQUIRES round is 1 or 2\n     //EFFECTS If Player wishes to order up a trump suit then return true and\n     //  change order_up_suit to desired suit.  If Player wishes to pass, then do\n     //  not modify order_up_suit and return false.\n     // In making trump, a Simple Player considers the upcard, which player dealt, and whether it is the first or second round of making trump. A more comprehensive strategy would consider the other players responses, but we will keep it simple.\n     // During round one, a Simple Player considers ordering up the suit of the upcard, which would make that suit trump. They will order up if that would mean they have two or more cards that are either face or ace cards of the trump suit (the right and left bowers, and Q, K, A of the trump suit, which is the suit proposed by the upcard). (A Simple Player does not consider whether they are the dealer and could gain an additional trump by picking up the upcard.)\n     // During round two, a Simple Player considers ordering up the suit with the same color as the upcard, which would make that suit trump. They will order up if that would mean they have one or more cards that are either face or ace cards of the trump suit in their hand (the right and left bowers, and Q, K, A of the order-up suit). For example, if the upcard is a Heart and the player has the King of Diamonds in their hand, they will order up Diamonds. The Simple Player will not order up any other suit. If making reaches the dealer during the second round, we invoke screw the dealer, where the dealer is forced to order up. In the case of screw the dealer, the dealer will always order up the suit with the same color as the upcard.\n     bool make_trump(const Card &upcard, bool is_dealer,\n                     int round, Suit &order_up_suit) const;\n   \n     //REQUIRES Player has at least one card\n     //EFFECTS  If the trump suit is ordered up during round one, the dealer picks up the upcard. The dealer then discards the lowest card in their hand, even if this is the upcard, for a final total of five cards. (Note that at this point, the trump suit is the suit of the upcard.)\n     void add_and_discard(const Card &upcard);\n   \n     //REQUIRES Player has at least one card\n     //EFFECTS  Leads one Card from Player's hand according to their strategy\n     //  \"Lead\" means to play the first Card in a trick.  The card\n     //  is removed the player's hand.\n     //  When a Simple Player leads a trick, they play the highest non-trump card in their hand. If they have only trump cards, they play the highest trump card in their hand.\n     Card lead_card(Suit trump);\n   \n     //REQUIRES Player has at least one card\n     //EFFECTS  Plays one Card from Player's hand according to their strategy.\n     //  The card is removed from the player's hand.\n     //  When playing a card, Simple Players use a simple strategy that considers only the suit that was led. A more complex strategy would also consider the cards on the table.\n     //  If a Simple Player can follow suit, they play the highest card that follows suit. Otherwise, they play the lowest card in their hand.\n     Card play_card(const Card &led_card, Suit trump);\n   \n    private:\n     std::string name;\n     std::vector<Card> hand;\n   };\n\n// The Human Player reads input from the human user. You may assume all user input is correctly formatted and has correct values. You may also assume the user will follow the rules of the game and not try to cheat.\nclass HumanPlayer: public Player {\n    public:\n    //EFFECTS: Creates a SimplePlayer with the given name\n    HumanPlayer(const std::string &name);\n  \n    //EFFECTS: Returns player's name\n    const std::string & get_name() const;\n  \n    //REQUIRES player has less than MAX_HAND_SIZE cards\n    //EFFECTS  adds Card c to Player's hand\n    void add_card(const Card &c);\n  \n    //REQUIRES round is 1 or 2\n    //EFFECTS  If Player wishes to order up a trump suit then return true and\n  //  change order_up_suit to desired suit.  If Player wishes to pass, then do\n  //  not modify order_up_suit and return false.\n  //  When making trump reaches a Human Player, first print the Players hand. Then, prompt the user for their decision to pass or order up. The user will then enter one of the following: Spades, Hearts, Clubs, Diamonds, or pass to either order up the specified suit or pass. This procedure is the same for both rounds of making trump.\n    bool make_trump(const Card &upcard, bool is_dealer,\n                    int round, Suit &order_up_suit) const;\n  \n    //REQUIRES Player has at least one card\n    //EFFECTS  Player adds one card to hand and removes one card from hand.\n    //  If a Human Player is the dealer and someone orders up during the first round of making, the Human Player will pick up the upcard and discard a card of their choice. Print the Players hand and an option to discard the upcard. Then, prompt the user to select a card to discard. The user will then enter the number corresponding to the card they want to discard (or -1 if they want to discard the upcard).\n    void add_and_discard(const Card &upcard);\n  \n    //REQUIRES Player has at least one card\n    //EFFECTS  Leads one Card from Player's hand according to their strategy\n    //  \"Lead\" means to play the first Card in a trick.  The card\n    //  is removed the player's hand.\n    //  When it is the Human Players turn to lead or play a trick, first print the Players hand. Then, prompt the user to select a card. The user will then enter the number corresponding to the card they want to play.\n    Card lead_card(Suit trump);\n  \n    //REQUIRES Player has at least one card\n    //EFFECTS  Plays one Card from Player's hand according to their strategy.\n    //  The card is removed from the player's hand.\n    //   When it is the Human Players turn to lead or play a trick, first print the Players hand. Then, prompt the user to select a card. The user will then enter the number corresponding to the card they want to play.\n    Card play_card(const Card &led_card, Suit trump);\n  \n   private:\n    std::string name;\n    std::vector<Card> hand;\n   };"
  },
  "doc-0e0bd3b608d34f46fcc9677588da7b5b": {
    "content": "#ifndef PLAYER_HPP\n#define PLAYER_HPP\n/* Player.hpp\n *\n * Euchre player interface\n *\n * by Andrew DeOrio\n * awdeorio@umich.edu\n * 2014-12-21\n */\n\n\n#include \"Card.hpp\"\n#include <string>\n#include <vector>\n\nclass Player {\n public:\n  //EFFECTS returns player's name\n  virtual const std::string & get_name() const = 0;\n\n  //REQUIRES player has less than MAX_HAND_SIZE cards\n  //EFFECTS  adds Card c to Player's hand\n  virtual void add_card(const Card &c) = 0;\n\n  //REQUIRES round is 1 or 2\n  //MODIFIES order_up_suit\n  //EFFECTS If Player wishes to order up a trump suit then return true and\n  //  change order_up_suit to desired suit.  If Player wishes to pass, then do\n  //  not modify order_up_suit and return false.\n  virtual bool make_trump(const Card &upcard, bool is_dealer,\n                          int round, Suit &order_up_suit) const = 0;\n\n  //REQUIRES Player has at least one card\n  //EFFECTS  Player adds one card to hand and removes one card from hand.\n  virtual void add_and_discard(const Card &upcard) = 0;\n\n  //REQUIRES Player has at least one card\n  //EFFECTS  Leads one Card from Player's hand according to their strategy\n  //  \"Lead\" means to play the first Card in a trick.  The card\n  //  is removed the player's hand.\n  virtual Card lead_card(Suit trump) = 0;\n\n  //REQUIRES Player has at least one card\n  //EFFECTS  Plays one Card from Player's hand according to their strategy.\n  //  The card is removed from the player's hand.\n  virtual Card play_card(const Card &led_card, Suit trump) = 0;\n\n  // Maximum number of cards in a player's hand\n  static const int MAX_HAND_SIZE = 5;\n\n  // Needed to avoid some compiler errors\n  // NOTE: Do NOT write a destructor in the Player subclasses. The compiler-generated ones will work fine.\n  virtual ~Player() {}\n};\n\n//EFFECTS: Returns a pointer to a player with the given name and strategy\n//To create an object that won't go out of scope when the function returns,\n//use \"return new Simple(name)\" or \"return new Human(name)\"\n//Don't forget to call \"delete\" on each Player* after the game is over\nPlayer * Player_factory(const std::string &name, const std::string &strategy);\n\n//EFFECTS: Prints player's name to os\nstd::ostream & operator<<(std::ostream &os, const Player &p);\n#endif // PLAYER_HPP"
  },
  "doc-4aa6b1422f6e3432d67ef085d295b4f5": {
    "content": "#ifndef PACK_HPP\n#define PACK_HPP\n/* Pack.hpp\n *\n * Represents a pack of playing cards\n *\n * by Andrew DeOrio <awdeorio@umich.edu>\n * 2014-12-21\n */\n\n\n#include \"Card.hpp\"\n#include <array>\n#include <string>\n\nclass Pack {\npublic:\n  // EFFECTS: Initializes the Pack to be in the following standard order:\n  //          the cards of the lowest suit arranged from lowest rank to\n  //          highest rank, followed by the cards of the next lowest suit\n  //          in order from lowest to highest rank, and so on. \n  // NOTE: The standard order is the same as that in pack.in.\n  // NOTE: Do NOT use pack.in in your implementation of this function\n  // NOTE: The pack is initially full, with no cards dealt.\n  Pack();\n\n  // REQUIRES: pack_input contains a representation of a Pack in the\n  //           format required by the project specification\n  // MODIFIES: pack_input\n  // EFFECTS: Initializes Pack by reading from pack_input.\n  // NOTE: The pack is initially full, with no cards dealt.\n  Pack(std::istream& pack_input);\n\n  // REQUIRES: cards remain in the Pack\n  // EFFECTS: Returns the next card in the pack and increments the next index\n  Card deal_one();\n\n  // EFFECTS: Resets next index to first card in the Pack\n  void reset();\n\n  // EFFECTS: Shuffles the Pack and resets the next index. This\n  //          performs an in shuffle seven times. See\n  //          https://en.wikipedia.org/wiki/In_shuffle.\n  void shuffle();\n\n  // EFFECTS: returns true if there are no more cards left in the pack\n  bool empty() const;\n\nprivate:\n  static const int PACK_SIZE = 24;\n  std::array<Card, PACK_SIZE> cards;\n  int next; //index of next card to be dealt\n};\n\n#endif // PACK_HPP"
  }
}